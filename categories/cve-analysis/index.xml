<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CVE Analysis on msh1307</title>
    <link>https://msh1307.kr/categories/cve-analysis/</link>
    <description>Recent content in CVE Analysis on msh1307</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Jun 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://msh1307.kr/categories/cve-analysis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dothack 2025 &amp; Kernel ctf</title>
      <link>https://msh1307.kr/blog/exp204/</link>
      <pubDate>Mon, 16 Jun 2025 00:00:00 +0000</pubDate>
      
      <guid>https://msh1307.kr/blog/exp204/</guid>
      <description>작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.
sechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.
최근에 half 먼저 지급하겠다고 메일이 왔다.
mitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.
익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.
카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.
challenges 안정성 높히려고 익스를 많이 고쳤다.
mitigation instance에서 안정성을 박살내는 가장 큰 요인은 perf_event_context_sched_out() 에서 일어나는 최적화 때문이다.</description>
    </item>
    
    <item>
      <title>CVE-2022-1015 Linux kernel netfilter</title>
      <link>https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/</guid>
      <description>Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다.
capabilities로 나뉘어져 권한이 부여된다.
즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.
Namespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다.
여기엔 UID GID cred keys capabilites 등이 모두 포함된다.
nested namespace
유저의 namespace는 중첩될 수 있다.
그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다.
0개 혹은 더 많은 child namespace를 가질 수 있다.</description>
    </item>
    
    <item>
      <title>CVE-2022-42432 Linux kernel netfilter</title>
      <link>https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/</guid>
      <description>CVE-2022-42432 struct expr_ops expr_ops_osf = { .name	= &amp;#34;osf&amp;#34;, .alloc_len	= sizeof(struct nftnl_expr_osf), .max_attr	= NFTA_OSF_MAX, .set	= nftnl_expr_osf_set, .get	= nftnl_expr_osf_get, .parse	= nftnl_expr_osf_parse, .build	= nftnl_expr_osf_build, .output	= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.
struct nftnl_expr_osf { enum nft_registers	dreg; uint8_t	ttl; uint32_t	flags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(&amp;amp;osf-&amp;gt;dreg, data, sizeof(osf-&amp;gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(&amp;amp;osf-&amp;gt;ttl, data, sizeof(osf-&amp;gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(&amp;amp;osf-&amp;gt;flags, data, sizeof(osf-&amp;gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다.</description>
    </item>
    
  </channel>
</rss>
