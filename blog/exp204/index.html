<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Google Kernel ctf exp204 | msh1307</title>
<meta name="keywords" content="dothack, kernel ctf">
<meta name="description" content="작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.
sechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.
발표 당시에만 하더라도 딱히 연락온게 없었는데, 최근에 half 먼저 지급하겠다고 메일이 왔다.
mitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.
익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.
카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.
challenges 안정성 높히려고 익스를 많이 고쳤다.">
<meta name="author" content="">
<link rel="canonical" href="https://msh1307.kr/blog/exp204/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9c43e0c7cae3b38c51e79921ad3cf2685d9811a56593a817d9b57ac4fdebf2b.css" integrity="sha256-2cQ&#43;DHyuOzjFHnmSGtPPJoXZgRpWWTqBfZtXrE/evys=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BR89V2WEC0');
</script>
<link rel="icon" href="https://msh1307.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://msh1307.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://msh1307.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://msh1307.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://msh1307.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Google Kernel ctf exp204" />
<meta property="og:description" content="작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.
sechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.
발표 당시에만 하더라도 딱히 연락온게 없었는데, 최근에 half 먼저 지급하겠다고 메일이 왔다.
mitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.
익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.
카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.
challenges 안정성 높히려고 익스를 많이 고쳤다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msh1307.kr/blog/exp204/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2025-06-16T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2025-06-16T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Google Kernel ctf exp204"/>
<meta name="twitter:description" content="작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.
sechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.
발표 당시에만 하더라도 딱히 연락온게 없었는데, 최근에 half 먼저 지급하겠다고 메일이 왔다.
mitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.
익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.
카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.
challenges 안정성 높히려고 익스를 많이 고쳤다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://msh1307.kr/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Google Kernel ctf exp204",
      "item": "https://msh1307.kr/blog/exp204/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Google Kernel ctf exp204",
  "name": "Google Kernel ctf exp204",
  "description": "작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.\nsechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.\n발표 당시에만 하더라도 딱히 연락온게 없었는데, 최근에 half 먼저 지급하겠다고 메일이 왔다.\nmitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.\n익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.\n카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.\nchallenges 안정성 높히려고 익스를 많이 고쳤다.",
  "keywords": [
    "dothack", "kernel ctf"
  ],
  "articleBody": "작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.\nsechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.\n발표 당시에만 하더라도 딱히 연락온게 없었는데, 최근에 half 먼저 지급하겠다고 메일이 왔다.\nmitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.\n익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.\n카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.\nchallenges 안정성 높히려고 익스를 많이 고쳤다.\nmitigation instance에서 안정성을 박살내는 가장 큰 요인은 perf_event_context_sched_out() 에서 일어나는 최적화 때문이다.\n취약점 자체가 race condition 쪽이라 트리거 시도를 많이 해야 한다.\nTimer interrupt 받아서 scheduler가 돌면 event group을 sched_in 시키거나 sched_out 시키는데, 이게 exploit 하는 입장에선 상당히 골치 아프다.\n취약점 자체가 부모 프로세스와 상속된 자식 프로세스간 events의 구성 불일치와 관련되어 있기에 context 필드가 되게 중요한데, 위 최적화가 막 context를 swap 해버린다.\n만약 그룹 소유권을 가진 프로세스가 죽으면 더 이상 다른 어떠한 프로세스도 해당 event group에 수정을 가할 수 없게 되어서 트리거 시도를 더 이상 못하게 된다.\n처음에 생각했던 방법은 아주 간단했다.\n그냥 무지성으로 프로세스 다 죽이고, 처음부터 다시 이벤트 그룹을 구성하고 트리거를 시도하는 방법이다.\n그러면 최적화 신경 안써도 되기 때문에 매우 편하다.\n하지만 한번 트리거하는데 기본 몇 시간씩 걸리고, 안정성이 박살난다.\n그래서 그 다음으로 생각했던 방법이, cpu pinning을 적절하게 해주면 프로세스 스케쥴링을 어느정도 통제할 수 있으니까 그걸 이용해서 최적화를 우회하는 방법이였다.\n기본적으로 해당 최적화는 자식 프로세스와 부모 프로세스의 이벤트들이 같은 그룹내에 속해 있는 경우에만 발생한다.\nstatic void do_perf_sw_event(enum perf_type_id type, u32 event_id, u64 nr, struct perf_sample_data *data, struct pt_regs *regs) { struct swevent_htable *swhash = this_cpu_ptr(\u0026swevent_htable); struct perf_event *event; struct hlist_head *head; rcu_read_lock(); head = find_swevent_head_rcu(swhash, type, event_id); if (!head) goto end; hlist_for_each_entry_rcu(event, head, hlist_entry) { if (perf_swevent_match(event, type, event_id, data, regs)) perf_swevent_event(event, nr, data, regs); } end: rcu_read_unlock(); } 상속된 이벤트들은 무조건 부모 이벤트 계측 cpu랑 같아야 한다.\n그래야 실제로 cpu hash table에서 제대로 꺼내와지고 계측된다.\n근데 문제는 fork 같은 syscall들을 써서 cpu를 처음부터 완벽하게 고정시킬 수 없다.\ncpu 처리 속도가 너무 빨라서 초반에 time slice 만료 이전에 swap 한번 해버리고 막아버려도 별 의미가 없다.\n마지막으로 생각했던 방법은 그룹 구성을 다르게 하는 것이다.\n잘 생각해보면, context를 swap 하는 것은 애초에 그룹 구성이 같다는 것을 전제로 동작한다.\n그래서 이 사실을 다음과 같은 방법으로 이용할 수 있다.\nelse if (child_pid \u003e 0) { // parent race_layout_index += 2; int tmp = perf_event_open(\u0026pe, 0, CPU_A, -1, 0); close(tmp); usleep(20000); kill(child_pid, SIGCONT); // now we pinned the ownership. now child process is allowed to exit. 스케쥴러를 최대한 예측 가능하게 만들려면, 자식 프로세스에서 그룹에 어떠한 수정도 주지 않은 상태에서 SIGSTOP을 raise 해놓고 부모에서 위 코드를 실행하면 된다.\n그러면 계속 ctx swap 된다.\nrace를 트리거하려면 어차피 두 프로세스를 병렬적으로 실행시켜야 하지만, 초반부에만 이렇게 동작하도록 강제해주면 되게 쉽게 소유권을 고정시켜줄 수 있다.\n부모 프로세스로 실행 흐름이 돌아왔다는 것은 부모 context가 돌아온 것이니, 그때 바로 더미 이벤트를 만들어서 고정시켜버리면 모든 문제가 해결된다.\n해당 방법을 이용해서 속도를 엄청나게 빠르게 개선했고, 안정성도 매우 높게 나오게 만들었다.\n사실 최적화쪽 코드를 완벽하게 이해하고 있었으면, 이렇게 돌고 돌아서 익스하진 않았을텐데 처음에 정확하게 구조를 이해하는게 확실히 중요한거 같다.\n이건 컨퍼런스 사진이다.\n",
  "wordCount" : "490",
  "inLanguage": "en",
  "datePublished": "2025-06-16T00:00:00Z",
  "dateModified": "2025-06-16T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://msh1307.kr/blog/exp204/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "msh1307",
    "logo": {
      "@type": "ImageObject",
      "url": "https://msh1307.kr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR89V2WEC0');
    </script>
    <nav class="nav">
        <div class="logo">
            <a href="https://msh1307.kr" accesskey="h" title="msh1307 (Alt + H)">msh1307</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://msh1307.kr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://msh1307.kr">Home</a>&nbsp;»&nbsp;<a href="https://msh1307.kr/blog/">Blogs</a></div>
    <h1 class="post-title">
      Google Kernel ctf exp204
    </h1>
    <div class="post-meta">


June 2025

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#challenges" aria-label="challenges">challenges</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>작년 고3때 제출했던 exp204로 dothack 2025 컨퍼런스에서 발표를 진행했다.<br>
sechack이랑 나랑 각자 CVE-2023-6931, CVE-2023-5717을 맡았다.</p>
<p>발표 당시에만 하더라도 딱히 연락온게 없었는데, 최근에 half 먼저 지급하겠다고 메일이 왔다.<br>
<img loading="lazy" src="/blog/exp204/exp204_00.png" alt=""  />
</p>
<p>mitigation instance의 경우 exploit reliability 70%를 넘겨야 mitigation 우회로 인정해줘서 안정성 높히는데 많은 시간을 썼다.<br>
익스 자체는 고3때 끝내긴 했었는데, 무슨짓을 해도 70%를 못넘겨서 좀 오래 걸렸다.</p>
<p>카이스트 입학하고 2월달 쯤부터 기숙사에서 익스 안정성 높히는데 시간을 많이 썼다.<br>
<img loading="lazy" src="/blog/exp204/exp204_01.png" alt=""  />
</p>
<h1 id="challenges">challenges<a hidden class="anchor" aria-hidden="true" href="#challenges">#</a></h1>
<p>안정성 높히려고 익스를 많이 고쳤다.<br>
mitigation instance에서 안정성을 박살내는 가장 큰 요인은 <code>perf_event_context_sched_out()</code> 에서 일어나는 최적화 때문이다.</p>
<p>취약점 자체가 race condition 쪽이라 트리거 시도를 많이 해야 한다.<br>
Timer interrupt 받아서 scheduler가 돌면 event group을 sched_in 시키거나 sched_out 시키는데, 이게 exploit 하는 입장에선 상당히 골치 아프다.<br>
취약점 자체가 부모 프로세스와 상속된 자식 프로세스간 events의 구성 불일치와 관련되어 있기에 context 필드가 되게 중요한데, 위 최적화가 막 context를 swap 해버린다.<br>
만약 그룹 소유권을 가진 프로세스가 죽으면 더 이상 다른 어떠한 프로세스도 해당 event group에 수정을 가할 수 없게 되어서 트리거 시도를 더 이상 못하게 된다.</p>
<p>처음에 생각했던 방법은 아주 간단했다.<br>
그냥 무지성으로 프로세스 다 죽이고, 처음부터 다시 이벤트 그룹을 구성하고 트리거를 시도하는 방법이다.<br>
그러면 최적화 신경 안써도 되기 때문에 매우 편하다.<br>
하지만 한번 트리거하는데 기본 몇 시간씩 걸리고, 안정성이 박살난다.</p>
<p>그래서 그 다음으로 생각했던 방법이, cpu pinning을 적절하게 해주면 프로세스 스케쥴링을 어느정도 통제할 수 있으니까 그걸 이용해서 최적화를 우회하는 방법이였다.<br>
기본적으로 해당 최적화는 자식 프로세스와 부모 프로세스의 이벤트들이 같은 그룹내에 속해 있는 경우에만 발생한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_perf_sw_event</span>(<span style="color:#66d9ef">enum</span> perf_type_id type, u32 event_id,
</span></span><span style="display:flex;"><span>				    u64 nr,
</span></span><span style="display:flex;"><span>				    <span style="color:#66d9ef">struct</span> perf_sample_data <span style="color:#f92672">*</span>data,
</span></span><span style="display:flex;"><span>				    <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> swevent_htable <span style="color:#f92672">*</span>swhash <span style="color:#f92672">=</span> <span style="color:#a6e22e">this_cpu_ptr</span>(<span style="color:#f92672">&amp;</span>swevent_htable);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> perf_event <span style="color:#f92672">*</span>event;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> hlist_head <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_lock</span>();
</span></span><span style="display:flex;"><span>	head <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_swevent_head_rcu</span>(swhash, type, event_id);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> end;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hlist_for_each_entry_rcu</span>(event, head, hlist_entry) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">perf_swevent_match</span>(event, type, event_id, data, regs))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">perf_swevent_event</span>(event, nr, data, regs);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>end:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>상속된 이벤트들은 무조건 부모 이벤트 계측 cpu랑 같아야 한다.<br>
그래야 실제로 cpu hash table에서 제대로 꺼내와지고 계측된다.<br>
근데 문제는 fork 같은 syscall들을 써서 cpu를 처음부터 완벽하게 고정시킬 수 없다.</p>
<p>cpu 처리 속도가 너무 빨라서 초반에 time slice 만료 이전에 swap 한번 해버리고 막아버려도 별 의미가 없다.</p>
<p>마지막으로 생각했던 방법은 그룹 구성을 다르게 하는 것이다.<br>
잘 생각해보면, context를 swap 하는 것은 애초에 그룹 구성이 같다는 것을 전제로 동작한다.</p>
<p>그래서 이 사실을 다음과 같은 방법으로 이용할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (child_pid <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">// parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        race_layout_index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">perf_event_open</span>(<span style="color:#f92672">&amp;</span>pe, <span style="color:#ae81ff">0</span>, CPU_A, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>); 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(tmp);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">usleep</span>(<span style="color:#ae81ff">20000</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kill</span>(child_pid, SIGCONT); <span style="color:#75715e">// now we pinned the ownership. now child process is allowed to exit.
</span></span></span></code></pre></div><p>스케쥴러를 최대한 예측 가능하게 만들려면, 자식 프로세스에서 그룹에 어떠한 수정도 주지 않은 상태에서 SIGSTOP을 raise 해놓고 부모에서 위 코드를 실행하면 된다.<br>
그러면 계속 ctx swap 된다.<br>
race를 트리거하려면 어차피 두 프로세스를 병렬적으로 실행시켜야 하지만, 초반부에만 이렇게 동작하도록 강제해주면 되게 쉽게 소유권을 고정시켜줄 수 있다.<br>
부모 프로세스로 실행 흐름이 돌아왔다는 것은 부모 context가 돌아온 것이니, 그때 바로 더미 이벤트를 만들어서 고정시켜버리면 모든 문제가 해결된다.</p>
<p>해당 방법을 이용해서 속도를 엄청나게 빠르게 개선했고, 안정성도 매우 높게 나오게 만들었다.</p>
<p>사실 최적화쪽 코드를 완벽하게 이해하고 있었으면, 이렇게 돌고 돌아서 익스하진 않았을텐데 처음에 정확하게 구조를 이해하는게 확실히 중요한거 같다.</p>
<p>이건 컨퍼런스 사진이다.<br>
<img loading="lazy" src="/blog/exp204/exp204_05.jpg" alt=""  />
<br>
<img loading="lazy" src="/blog/exp204/exp204_08.jpg" alt=""  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://msh1307.kr/tags/dothack/">dothack</a></li>
      <li><a href="https://msh1307.kr/tags/kernel-ctf/">kernel ctf</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://msh1307.kr">msh1307</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
